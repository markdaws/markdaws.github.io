<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[markdaws.net]]></title><description><![CDATA[Musings by a dude on the internet]]></description><link>http://markdaws.net/blog/</link><generator>Ghost v0.4.2</generator><lastBuildDate>Sun, 20 Apr 2014 23:06:19 GMT</lastBuildDate><atom:link href="http://markdaws.net/blog/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Do you want to build a 3D Engine? - Part 1]]></title><description><![CDATA[<h3 id="whatisa3dengine">What is a 3D Engine?</h3>

<p>The main purpose of a 3D engine is to take descriptions of objects in a 3-dimensional world and render these objects on your 2-dimensional monitor.  You also want to be able to take inputs, such as key presses, mouse events to manipulate the 3D world, such as moving around and interacting with objects in the world.</p>

<h3 id="components">Components</h3>

<p>Most 3D Engine have the following basic parts, they may be named something different or be connected in slightly different ways, but the overall concepts are the same.  Below is an example of a 3D scene are rendered in the Unity Game Engine: <br />
<img src='http://markdaws.net/blog/content/images/2014/Apr/basic_scene.jpg'  alt="Example Scene" /></p>

<h4 id="meshesmaterials">Meshes + Materials</h4>

<p>Meshes are the building blocks of a 3D engine. A mesh is generally a combination of 3D geometry and materials that describe how to render a 3D object. The geometry is a combination of 3D points [(x1, y1, z1), (x2, y2, z2) ...] along with a description of the ordering to render these points.  If you notice in the scene, the objects are all made out of multiple triangles, even the sphere is rendered using multiple triangles.  This is because triangles have a lot of properties that make then very efficient to render, so when you have a number of 3D points, you also have to specify how the points are connected together to make the triangles. For example, maybe one triangle is made by connecting p1, p2, p3 and another triangle p3, p4, p5 and so on.  In the example below, you can see the sphere, cube and plane are all make from multiple triangles: <br />
<img src='http://markdaws.net/blog/content/images/2014/Apr/meshes.jpg'  alt="Meshes Example" /></p>

<p>As well as the geometry, a mesh contains materials.  Materials describe given a triangle, how should it's surface be rendered to the screen, should it be a solid colour, transparent, rendered using a texture (image), animated.  There are many ways it can be rendered and a single mesh may have multiple materials associated with it.  For example, if we are rendering a 3D car, there might be one material that renders the body paint, another for the glass, another for the tyres etc.</p>

<h4 id="lights">Lights</h4>

<p>In order to be able to see anything, as in the real world, you need to define what lights are in a scene.  The light could be an ambient light (a fixed amount of constant light that falls on all surfaces), a directional light, a point light etc.  A scene could contain many different light sources. In the example above you can see a light source illuminating the sphere.</p>

<h4 id="cameras">Cameras</h4>

<p>A scene has to be rendered from a point of view.  A camera will mainly be defined by a position, a look direction and a field of view.  The field of view describes how much of the world can be viewed at one time.  It is possible to have multiple cameras in the world, for example in multiplayer games, the world is being rendered from multiple views at any point in time.  In the scene above, you can see a camera looking at the sphere, the pyramid attached to the camera shows the camera "view frustum", if a 3D object is inside the view frustum bounds it will be rendered, otherwise it will be ignored.</p>

<h4 id="scenegraphs">Scene Graphs</h4>

<p>Once your worlds start getting more complicated, scene graphs come into play.  You can think of a scene graph as a hierarchy, where nodes higher in the tree own child nodes.  A node can contain a description that should be applied to all of the child nodes.  For example if you imagine modelling an arm and a hand, if you move the forearm up, then you want the hand to also follow, so we define a transform for the forearm movement and this transform is applied to the hand as well to keep it in sync, the hand is a child of the forearm.</p>

<p>Scene graphs can also be used to specify in what order things should be drawn, when transparencies come into play, the order you render object is important.</p>

<p>They can also be used to improve performance, you can use the tree to quickly determine if a part of the scene is visible or not to the camera, if it's not then there is no need trying to draw it.</p>

<h4 id="picking">Picking</h4>

<p>A 3D Engine will also be responsible for providing a way to interact with object in the scene.  This is generally called picking. You take a position on the 2D screen and turn that position into a ray that you shoot back into the 3D world, and see if the ray hits any objects.  You can then use this for moving objects around.</p>

<h3 id="sowhatsagameengine">So what's a game engine?</h3>

<p>A game engine is something more fully featured than just a 3D engine, like <a href='http://unity3d.com/' >Unity</a>. It provides some or all of the following:</p>

<ul>
<li>2D / 3D graphics</li>
<li>Sound</li>
<li>Asset management (importing meshes from various modelling tools)</li>
<li>Interface building</li>
<li>GUI tools for building worlds</li>
</ul>

<p>This series of articles only focusses on the 3D graphics portion, but I would definitely recommend learning how a fully featured game engine like Unity works, to get a feel for all the parts that are required to develop a 3D application.  Although writing your own solution from scratch is definitely fun, it you want to develop a project quickly with support for many assets and effects, you definitely should look in to using an existing engine, rather than writing your own from scratch.</p>

<h3 id="nexttime">Next time</h3>

<p>In the next part of this series we will look at some of the fundamental mathematical concepts, such as points, vectors, matrices, quaternions then with that as a base, move on to actually rendering some content on the screen.</p>]]></description><link>http://markdaws.net/blog/do-you-want-to-build-a-3d-engine-part-1/</link><guid isPermaLink="false">2d081b14-b392-49bf-9ed3-110251c450c9</guid><dc:creator><![CDATA[Mark Dawson]]></dc:creator><pubDate>Sun, 20 Apr 2014 23:01:25 GMT</pubDate></item><item><title><![CDATA[Do you want to build a 3D Engine?]]></title><description><![CDATA[<p>I've always had a love for 3D graphics and I've written several 3D Graphics Engines for projects that I have worked on over the years.  The great thing about really understanding the fundamentals of 3D rendering and the math behind it is that you can easily move from one engine to another as the high level concepts in most engines always tie back to the fundamentals.</p>

<h3 id="code">Code</h3>

<p>In this series of articles we will create a 3D engine from scratch, the source code will be checked into GitHub here: <a href='https://github.com/markdaws/hamilton' >Hamilton</a>. The name Hamilton is a reference to <a href='http://en.wikipedia.org/wiki/William_Rowan_Hamilton' >William Hamilton</a> who first described Quaternions, something we will use frequently in our graphical discussions.</p>

<h3 id="technologies">Technologies</h3>

<p>In terms of technologies, we will be using JavaScript, WebGL and Canvas.  My aim will be to let the framework switch between WebGL and Canvas for some basic functionality, while reserving advanced techniques for WebGL (things such as shaders, which we will get to at some point).  At some point I would like to create a series on <a href='https://unity3d.com/unity' >Unity3D</a> that map back to these tutorials, keep posted.</p>

<h3 id="chapters">Chapters</h3>

<p>I'll update the index below as I get to writing new chapters.  The first few will be a bit abstract, but are core to your understanding of a 3D world,</p>

<ol>
<li><a href='http://markdaws.net/blog/do-you-want-to-build-a-3d-engine-part-1' >What is a 3D engine?</a>  </li>
<li>Vectors + Points  </li>
<li>Matrices  </li>
<li>Transforms  </li>
<li>Quaternions  </li>
<li>Projection  </li>
<li>Geometry  </li>
<li>Materials  </li>
<li>Animation</li>
</ol>

<p>Lets get started shall we :)</p>]]></description><link>http://markdaws.net/blog/do-you-want-to-build-a-3d-engine/</link><guid isPermaLink="false">1437e1e8-2da9-4050-918e-fadfc99940c7</guid><dc:creator><![CDATA[Mark Dawson]]></dc:creator><pubDate>Sun, 20 Apr 2014 23:01:12 GMT</pubDate></item><item><title><![CDATA[Fast, free blog courtesy of Ghost, GitHub and Buster]]></title><description><![CDATA[<h3 id="owningyourblogcontentisimportant">Owning your Blog content is important</h3>

<p>Blogging platforms du jour come and go and if you have put a lot of time and effort in to writing content on a blog you don't want to see it disappear when a service is shut down or merged with another company.  </p>

<p>For me, I've had several blogs, back when I could call myself a C# expert, I wrote lots of detailed articles on the internals of C# on my Microsoft Live Spaces blog (anyone remember that platform), alas it has long been shuttered and all the content I produced, lost. This time I wanted to be the last time I setup a blog, along with several criteria:</p>

<ul>
<li>It should be easy to completely control the look and feel of my blog</li>
<li>I can run the blog locally if needed</li>
<li>Minimal cost to host the blog</li>
<li>Fast and capable of handling traffic spikes (never know when HN comes calling :P)</li>
</ul>

<h3 id="solutiongithubpagesghostbustercostd0">Solution - Github Pages + Ghost + Buster - Cost $0</h3>

<p>What I ended up with was using the following services:  </p>

<h4 id="ghost">Ghost</h4>

<p><a href='https://ghost.org/' >Ghost</a> is a fully featured blogging platform written on <a href='http://nodejs.org/' >node.js</a> It is easy to quickly create beautiful looking websites, I liked it because of how simple it was to get up and running, plus the source code is also available that allows easy modification if needed.  </p>

<p>By default, Ghost requires a server to host the service, but I didn't want to have the hassle of setting up my own server, or opening a hosting account with a company that hosts Ghost blogs, so instead I went to route of turning my Ghost installation into a static website, which I can easily host for free. </p>

<h4 id="busterghoststaticsitegenerator">Buster - Ghost -> static site generator</h4>

<p><a href='https://github.com/axitkhurana/buster' >Buster</a> can be pointed at any Ghost blog, either one hosted on an external website, or one running locally on your own computer and output a directory with the static content of the site, HTML, CSS, images, fonts etc.  </p>

<p>This is great and simplifies the hosting options.  Simply install Ghost locally, then run Buster on it to generate a static site, the final step is to then find somewhere to host your static site.  </p>

<h4 id="githubwebsitehosting">GitHub - website hosting</h4>

<p><a href='http://github.com/' >Github</a> is a service mainly for programmers that allows them to store and share code.  However one nice feature of GitHub is something called <a href='https://pages.github.com/' >GitHub Pages</a> that allows you to easily create static websites for your projects.  I used GitHub pages to host the static Ghost site we generated using Buster.</p>

<h3 id="settingupyourblog">Setting Up Your Blog</h3>

<p><strong>NOTE:</strong> I'm assuming you are not afraid of the command line and some HTML/CSS tweaking, if you are this solution is not for you.</p>

<p>Below are the steps I followed to get this blog up and running, it was suprising painless:</p>

<ol>
<li>Create a <a href='http://github.com/' >GitHub</a> account  </li>
<li>Install <a href='http://docs.ghost.org/installation/' >Ghost</a> locally on your computer  </li>
<li>Install <a href='http://www.metacotta.com/ghost-static-site-generation-with-buster/' >Buster</a>  </li>
<li>Setup <a href='https://pages.github.com/' >GitHub Pages</a> for the repository you are going to use to host the blog. <strong>BONUS</strong>: if you want to setup a custom domain, follow <a href='https://help.github.com/articles/setting-up-a-custom-domain-with-pages' >these</a> instructions.  </li>
<li>Modify config.js in your Ghost source code folder to update the URLs used on your site.  </li>
<li>To create a new theme for your site, follow the instructions <a href='http://docs.ghost.org/themes/' >here</a></li>
</ol>

<p>By this point you should have a local installation of Ghost running, created a few test articles, converted it to a static site using Buster and finally pushed the static site code to your GitHub pages repository and be looking at your spanking new site on the Interwebs.</p>

<h3 id="backingup">Backing Up</h3>

<p>An important part of the process is backing up your customized blog and articles.  With Ghost, we want to make sure we backup:</p>

<ul>
<li>Articles via sqlite DB</li>
<li>Modified Theme</li>
<li>Config changes</li>
</ul>

<p>I simply uploaded my whole ghost directory (minus the node_modules folder) to GitHub, this is so I have a copy of my modified theme, the articles DB and the entire site source code if needed.</p>

<h3 id="conclusion">Conclusion</h3>

<p>I found Ghost to be amazingly simple to setup and customize and easy to convert into a static site for <strong>FREE</strong> hosting on GitHub. Also I now have complete peace of mind that I will never lose my blog content again.  Happy blogging.</p>]]></description><link>http://markdaws.net/blog/fast-free-blog-courtesy-of-ghost-github-and-buster/</link><guid isPermaLink="false">d8d0853a-3e9d-42e5-ab82-443365864292</guid><category><![CDATA[github]]></category><category><![CDATA[ghost]]></category><category><![CDATA[blogging]]></category><category><![CDATA[tutorial]]></category><category><![CDATA[nodejs]]></category><dc:creator><![CDATA[Mark Dawson]]></dc:creator><pubDate>Wed, 16 Apr 2014 22:21:14 GMT</pubDate></item></channel></rss>