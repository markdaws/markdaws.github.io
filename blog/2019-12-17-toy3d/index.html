<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Mark Dawson">
<title>Toy3D - simple 3D engine using Swift + Metal</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Toy3D - simple 3D engine using Swift + Metal</h1>
<div class="details">
<span id="author" class="author">Mark Dawson</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2019-12-17</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_about">About</a>
<ul class="sectlevel2">
<li><a href="#_source">Source</a></li>
<li><a href="#_software_versions">Software Versions</a></li>
<li><a href="#_resources">Resources</a></li>
</ul>
</li>
<li><a href="#_3d_fundamentals">3D Fundamentals</a>
<ul class="sectlevel2">
<li><a href="#_defining_a_3d_model">Defining a 3D Model</a></li>
<li><a href="#_local_vs_world_space">Local vs. World Space</a></li>
<li><a href="#_object_hierarchies">Object Hierarchies</a></li>
<li><a href="#_eye_camera_space">Eye / Camera Space</a></li>
<li><a href="#_projection_3d_2d">Projection (3D &#8594; 2D)</a></li>
<li><a href="#_summary">Summary</a></li>
</ul>
</li>
<li><a href="#_metal">Metal</a>
<ul class="sectlevel2">
<li><a href="#_what_is_metal">What is Metal?</a></li>
<li><a href="#_what_is_metalkit">What is MetalKit?</a></li>
<li><a href="#_shaders">Shaders</a></li>
<li><a href="#_core_types">Core Types</a>
<ul class="sectlevel3">
<li><a href="#_mtldevice">MTLDevice</a></li>
<li><a href="#_mtlcommandqueue">MTLCommandQueue</a></li>
<li><a href="#_mtkview">MTKView</a></li>
<li><a href="#_mtkviewdelegate">MTKViewDelegate</a></li>
<li><a href="#_mtldrawable">MTLDrawable</a></li>
<li><a href="#_mtlrenderpipelinestate_mtlrenderpipelinedescriptor">MTLRenderPipelineState / MTLRenderPipelineDescriptor</a></li>
<li><a href="#_mtlcommandbuffer">MTLCommandBuffer</a></li>
<li><a href="#_mtlrenderpassdescriptor">MTLRenderPassDescriptor</a></li>
<li><a href="#_mtlrenderpasscommandencoder">MTLRenderPassCommandEncoder</a></li>
<li><a href="#_mtltexture_mtktextureloader">MTLTexture / MTKTextureLoader</a></li>
<li><a href="#_mtlsamplerdescriptor_mtlsamplerstate">MTLSamplerDescriptor / MTLSamplerState</a></li>
</ul>
</li>
<li><a href="#_memory_layout">Memory Layout</a>
<ul class="sectlevel3">
<li><a href="#_size_stride_alignment">Size / Stride / Alignment</a></li>
<li><a href="#_floatn_packed_floatn">floatN / packed_floatN</a></li>
<li><a href="#_simd">SIMD</a></li>
</ul>
</li>
<li><a href="#_mtlvertexdescriptor">MTLVertexDescriptor</a></li>
</ul>
</li>
<li><a href="#_3d_engine">3D Engine</a>
<ul class="sectlevel2">
<li><a href="#_disclaimer">Disclaimer</a></li>
<li><a href="#_overview">Overview</a></li>
<li><a href="#_vec2_vec3_vec4_mat4">Vec2 / Vec3 / Vec4 / Mat4</a></li>
<li><a href="#_renderer">Renderer</a></li>
<li><a href="#_scene">Scene</a></li>
<li><a href="#_perspectivecamera">PerspectiveCamera</a></li>
<li><a href="#_mesh">Mesh</a></li>
<li><a href="#_node">Node</a></li>
<li><a href="#_material">Material</a></li>
<li><a href="#_texture">Texture</a></li>
<li><a href="#_basicvertex">BasicVertex</a></li>
<li><a href="#_time">Time</a></li>
<li><a href="#_buffers">Buffers</a>
<ul class="sectlevel3">
<li><a href="#_synchronizing_memory_access">Synchronizing Memory Access</a></li>
<li><a href="#_setvertexbytes">setVertexBytes</a></li>
</ul>
</li>
<li><a href="#_model_io">Model I/O</a></li>
</ul>
</li>
<li><a href="#_examples">Examples</a></li>
<li><a href="#_future">Future</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_about">About</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Toy3D is a simple 3D engine built using <a href="https://developer.apple.com/swift/">Swift</a>, <a href="https://developer.apple.com/metal/">Metal</a> and <a href="https://developer.apple.com/documentation/metalkit">MetalKit</a>.
Toy3D is not intended to be a high performance 3D engine or even used in any real application, it doesn&#8217;t have any fancy optimizations or a large feature set.</p>
</div>
<div class="paragraph">
<p>Its purpose is to allow someone to work through the basics of creating a simple 3D engine and learn about the core concepts of Metal and hopefully the code is simple enough that you can open the source and easily follow along.</p>
</div>
<div class="paragraph">
<p>The reason why creating a simple 3D engine is a great learning experience is because most tutorials will show you the basics and get a triangle or cube rendering on the screen, which is great, but then actually trying to use that information to render &gt;1 objects is another leap.
How do you organize your code to handle encoding more than one model, what are the lifetime of different objects, how can you efficiently send multiple draw calls to the GPU etc.</p>
</div>
<div class="paragraph">
<p>It is assumed that you have a basic understanding of 3D math concepts such as Vectors and Matrices. If not then I would recommend this book <a href="https://www.essentialmath.com/book.htm">Essential Math for Games Programmers</a>.
It&#8217;s a really great resource for all of the core math concepts you will use in a 3D engine.</p>
</div>
<div class="sect2">
<h3 id="_source">Source</h3>
<div class="paragraph">
<p>You can find all of the source code for the engine <a href="https://github.com/markdaws/Toy3D">https://github.com/markdaws/Toy3D</a>.
It is setup as a Swift package so you can easily include it in your own code.</p>
</div>
<div class="paragraph">
<p>There is an example project that uses the library and creates some simple 3D scenes here: <a href="https://github.com/markdaws/metal-example" class="bare">https://github.com/markdaws/metal-example</a></p>
</div>
<div class="paragraph">
<p>If you find any issues or have any questions feel free to create some issues in the repository.</p>
</div>
</div>
<div class="sect2">
<h3 id="_software_versions">Software Versions</h3>
<div class="paragraph">
<p>The following software versions were used at the time of writing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Xcode 11</p>
</li>
<li>
<p>Swift 5.1</p>
</li>
<li>
<p>iOS 12</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_resources">Resources</h3>
<div class="paragraph">
<p>Here are a list of resources for Swift + Metal</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/metal">Metal Documentation</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/metalkit">MetalKit Documentation</a></p>
</li>
<li>
<p><a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html">Swift Language Reference</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">Metal Shader Language Specification</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/MTLBestPracticesGuide/index.html">Metal Best Practices</a></p>
</li>
<li>
<p><a href="https://metalbyexample.com">Metal By Example</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/videos/graphics-and-games/metal">WWDC Metal Talks</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf">Metal features by processor family</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3d_fundamentals">3D Fundamentals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we talk about Metal or the implementation of our 3D engine we need to understand a few core concepts around 3D graphics, along with the basics of how you take points in a 3D space and convert them to pixels on a 2D screen.</p>
</div>
<div class="paragraph">
<p>If you are already familiar with how 3D graphics work at a high level, then feel free to skip this whole section.</p>
</div>
<div class="sect2">
<h3 id="_defining_a_3d_model">Defining a 3D Model</h3>
<div class="paragraph">
<p>The first thing we need to do in order to render a 3D model to the screen is define what data we need and how to organize that data.
Let&#8217;s look at a 3D model and see how it works.
A great source of online 3D models is <a href="https://sketchfab.com">Sketchfab</a>, we will use this model of a house as an example.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/model-rendered.jpg" alt="model rendered">
</div>
<div class="title">A fully rendered 3D model (<a href="https://sketchfab.com/3d-models/ftm-0970f30574d047b1976ba0aa6f2ef855">Source</a>)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you visit the model on Sketchfab, their viewer has a model inspector option in the bottom right that exposes all the underlying model information, it is really fun to play around with.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first thing we need to define are the individual 3D x,y,z values that make up the model, the vertices.
When creating your 3D model in some modelling tool (or by hand!) we draw the content and end up with a long list of 3D points.
Along with the 3D points you also have to specify how these points are connected together to actually draw something more than just points (you would end up with a point cloud if you did that).
Typically GPUs like to process data in terms of triangles, they are a simple mathematical concept that have several simple properties that make them very fast to convert from 3D to points on a 2D screen.</p>
</div>
<div class="paragraph">
<p>So given a list of 3D points we also specify how those points connect, we specify the primitive, like a triangle and then let the GPU know which points correspond to which triangle.
This can be done by the implicit order of the 3D points in your vertex buffer e.g. p0, p1, p2 is triangle0, p3, p4, p5 is triangle1 and so on, or you can define an index buffer, which uses the index into the vertex buffer to define the triangles.
This has the advantage that you can use the same 3D point in more than one triangle, whereas with the previous method you would have to duplicate points.</p>
</div>
<div class="paragraph">
<p>Below is an example of taking the 3D points and defining how they are connected and rendering a plain model.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/model-wireframe.jpg" alt="model wireframe">
</div>
<div class="title">A wireframe view of the 3D model</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/model-unshaded.jpg" alt="model unshaded">
</div>
<div class="title">An untextured version of the model</div>
</div>
<div class="paragraph">
<p>Now that we can draw the geometry of the model, we want to make it look a bit more interesting.
This can be done by either just giving each point in a model a fixed color, or you can also specify that the 3D point should map to a 2D position in a texture, then use the texture to paint on to the model.</p>
</div>
<div class="paragraph">
<p>In the example below you can see the red dot on the left in the 3D model and on the right how the red dot is actually mapped to a 2D coordinate in the texture.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/model-diffuse.png" alt="model diffuse">
</div>
<div class="title">An example showing how a texture is mapped to the model geometry. Notice how the red dot on the 3D model maps to a location in the 2D texture</div>
</div>
<div class="paragraph">
<p>You can see how the 2D texture is filled with pieces of the 3D model surface. Typically 3D modelling tools will generate these for you.</p>
</div>
<div class="paragraph">
<p>Given this information we can see that our vertices are not only 3D positions but also other information.
If we generate a number of vertices for our model it might look something like position:uv:normal</p>
</div>
<div class="paragraph">
<p>[x0,y0,z0,u0,v0,nx0,ny0,nz0,x1,y1,z1,u1,v1,nx1,ny1,nz1, &#8230;&#8203; ]</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Texture coordinates are usually called u and v, with u being a horizontal offset into the texture and v being a vertical offset.
NOTE: We haven&#8217;t discussed normals yet, but (nx0, nxy0, nz0) is a vector that you can define for each vertex that defines how light behaves with the model.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With this information in mind you can see that a 3D API like Metal is concerned with efficiently taking all of the vertex information and associated content such as textures and trying to convert those into 2D images as fast as possible.</p>
</div>
</div>
<div class="sect2">
<h3 id="_local_vs_world_space">Local vs. World Space</h3>
<div class="paragraph">
<p>When 3D objects are created in a modelling tool, the points in the object are all relative to a "local" origin.
This is commonly referred to as local / object / model space.
The model is generally created so that the origin and axis make manipulating the object easier.</p>
</div>
<div class="paragraph">
<p>The local origin is normally either placed in the center of the object, if it&#8217;s something you want to rotate around the center e.g. a ball, or at the bottom of the object, for example if you modelled a vase having the origin at the bottom easily lets you place the object on another surface like a table without any extra manipulation.</p>
</div>
<div class="paragraph">
<p>When constructing our global 3D world with many individual objects in it, we have one world origin and set of axis x,y and z that are used by all objects.
This axis and origin act as a common reference amongst all objects in the world.</p>
</div>
<div class="paragraph">
<p>As models are placed in the world we transform their local points to world points using rotation, scaling and translation.
This is known as their model transform.
For example, if we modelled a 3D ball, the local origin of [0,0,0] might be in the center of the ball when we define all the 3D points in the ball, but when it&#8217;s placed in the world its origin might now be at [10,5,3].</p>
</div>
<div class="paragraph">
<p>One way to think of this would be if you were modelling a scene with multiple chairs, you would first create a single chair model, probably with the origin at the bottom of the legs to make it easy to put the chairs on the floor plane.
If we just insert multiple chairs in the world without any additional transforms, they would all overlap at the world origin since their 3D points would all be the same, we would only see one chair.
One way to work around this would be to actually define all of the points in the model in world space when you create it, but that would mean you would have to make N individual chair models, you couldn&#8217;t reuse just one instance of the model.</p>
</div>
<div class="paragraph">
<p>Instead we insert multiple instances of the same chair model, but on each chair we would set a different translation, scaling and rotation to transform each local chair to a final position in the world.
Their "local" 3D points are still all the same, but their final world 3D points now differ.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cubes.jpg" alt="cubes">
</div>
<div class="title">An example of multiple cubes transformed in to one world space (ironically created in Unity)</div>
</div>
</div>
<div class="sect2">
<h3 id="_object_hierarchies">Object Hierarchies</h3>
<div class="paragraph">
<p>We have talked about how an object is initially defined in local space, then we applied a set of transforms to define its appearance in world space.
However, it&#8217;s possible to apply more than one level of transforms to an object to affect its final appearance in world space.
We can specify an objects transform as being relative to a parent or ancestor objects.</p>
</div>
<div class="paragraph">
<p>For example, if we were making a static model of a subset of the solar system, you could draw the sun, earth and moon and place them in a scene with the following hierarchy:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Solar System
 -&gt; Sun
 -&gt; Earth
 -&gt; Moon</pre>
</div>
</div>
<div class="paragraph">
<p>Each item would then have a single transform applied to it to move it to a final world position.</p>
</div>
<div class="paragraph">
<p>However if you now wanted to animate the scene so that the sun rotates in place, the earth rotates around the sun and the moon around the earth, you would have to manually calculate the transforms each frame, taking in to account how the entity should move relative to the other entities.
This is a lot of duplicated calculation and makes the code more complicated.</p>
</div>
<div class="paragraph">
<p>A simpler way to model the scene would be instead with the following hierarchy:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Solar System
 -&gt; Sun
  -&gt; Earth
    -&gt; Moon</pre>
</div>
</div>
<div class="paragraph">
<p>Now to calculate the final world position of an entity, you start at the bottom and traverse up the hierarchy applying the transform at each level until you end up with one overall transform.</p>
</div>
<div class="paragraph">
<p>For example, if you wanted to calculate the overall world transform of the moon, you would do the following (transforms are applied from right to left):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>World Transform = T<sub>sun</sub> * T<sub>earth</sub> * T<sub>moon</sub></p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
T represents a transform, some combination of scaling, rotation and translation. Transforms are applied right to left in this case.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This makes everything very simple, as we rotate the sun, the earth and moon automatically get their final world transform updated without us having to explicitly set a new transform on them.</p>
</div>
<div class="paragraph">
<p>We will use this concept in our 3D engine to create a simple scene graph.</p>
</div>
</div>
<div class="sect2">
<h3 id="_eye_camera_space">Eye / Camera Space</h3>
<div class="paragraph">
<p>Now that we have all of the 3D points of our models in a single unified world space, we need to move on to the next step in our journey of figuring out how to get those 3D points on a 2D screen.</p>
</div>
<div class="paragraph">
<p>Just as we see the real world through the viewpoint of our location in the world and the position and orientation of our eyes we need to define where our 3D scene will be viewed from.
This is done by defining a camera object.</p>
</div>
<div class="paragraph">
<p>To define the camera we need a few basic properties:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Origin</dt>
<dd>
<p>The location of the camera in 3D space (x, y, z).</p>
</dd>
<dt class="hdlist1">Look Direction</dt>
<dd>
<p>A 3D vector specifying in which direction the camera is looking.</p>
</dd>
<dt class="hdlist1">Up Vector</dt>
<dd>
<p>Given a look direction we also need some way to specify the rotation of the camera.
If you imagine a look vector shooting out of your eyes, the look vector doesn&#8217;t change even as you tilt your head left or right.
The up vector helps clarify the camera rotation, normally this can just be set to (0,1,0).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>In our engine we are going to use a right hand coordinate system, this is where +x points to the right, +y is up and +z points towards the camera.
We could use a left handed coordinate system, it doesn&#8217;t really matter since at the end of the day we have to transform the points to the same representation the GPU expects, it would just change some of the matrices below.</p>
</div>
<div class="paragraph">
<p>To convert a point from world space to eye space we can use the following matrix transformation:</p>
</div>
<div class="listingblock">
<div class="title">Math.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">static</span> <span class="kd">func</span> <span class="nf">makeLook</span><span class="p">(</span>
  <span class="nv">eye</span><span class="p">:</span> <span class="kt">Vec3</span><span class="p">,</span>
  <span class="nv">look</span><span class="p">:</span> <span class="kt">Vec3</span><span class="p">,</span>
  <span class="nv">up</span><span class="p">:</span> <span class="kt">Vec3</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Mat4</span> <span class="p">{</span>

  <span class="k">let</span> <span class="nv">vLook</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">look</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">vSide</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">cross</span><span class="p">(</span><span class="n">vLook</span><span class="p">,</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">up</span><span class="p">)))</span>
  <span class="k">let</span> <span class="nv">vUp</span> <span class="o">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">cross</span><span class="p">(</span><span class="n">vSide</span><span class="p">,</span> <span class="n">vLook</span><span class="p">))</span>

  <span class="k">return</span> <span class="kt">Mat4</span><span class="p">([</span>
    <span class="kt">Vec4</span><span class="p">(</span><span class="n">vSide</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="kt">Vec4</span><span class="p">(</span><span class="n">vUp</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="kt">Vec4</span><span class="p">(</span><span class="n">vLook</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="kt">Vec4</span><span class="p">(</span><span class="o">-</span><span class="n">eye</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">])</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>I&#8217;m not going to go over the math to create this transform, but there are a vast number of resources on line if you want to find out more.</p>
</div>
<div class="paragraph">
<p>Needless to say, it is basically just subtracting the position of the camera from each point, to make the points relative the origin of the camera instead of the world origin, then rotating each point so that the camera up vector is considered up instead of the world up e.g. [0, 1, 0].</p>
</div>
</div>
<div class="sect2">
<h3 id="_projection_3d_2d">Projection (3D &#8594; 2D)</h3>
<div class="paragraph">
<p>Now we have taken the points in 3D world space and converted them in to values relative to a cameras view point, we need to now take a point in 3D and convert it in to a representation on a 2D plane so that it can be rendered on a screen.
The process of transforming 3D points to 2D space is called projection.</p>
</div>
<div class="paragraph">
<p>We will project points as we see them in the real world using Perspective Projection.
This is where parallel lines seem to converge to a point as they move further away from the viewing position.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/paul-jarvis-o0lnBAQ175A-unsplash.jpg" alt="paul jarvis o0lnBAQ175A unsplash">
</div>
<div class="title">An example of perspective (<a href="https://unsplash.com/photos/o0lnBAQ175A" class="bare">https://unsplash.com/photos/o0lnBAQ175A</a>)</div>
</div>
<div class="paragraph">
<p>In order to calculate our 3D &#8594; 2D transform we can think of the problem as taking the camera and having a flat plane on which all of the 3D points will be projected.
We will want this plane to have the same aspect ratio (width/height) as the screen we are rendering to so that they match.
We will also want to define some other planes, a far plane which specifies that any object further than this plane we don&#8217;t want to render.
Theoretically we don&#8217;t need this, we could render everything but in graphics we generally want to limit the number of object we render for performance purposes.
We also need a near plane, this stops objects too close to the camera being rendered which can cause weird issues with division by 0 etc.
These two planes will be controlled by values zNear and zFar.</p>
</div>
<div class="paragraph">
<p>The last piece of information we need is a field of view.
The field of view specifies how wide or narrow the camera can view.
If you have a narrow field of view it is like zooming the camera in, making the field of view larger is like zooming out on the camera.</p>
</div>
<div class="paragraph">
<p>Given this we end up with something like below:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/frustum.jpg" alt="frustum">
</div>
<div class="title">View Frustum (<a href="https://stackoverflow.com/a/5836522/61811" class="bare">https://stackoverflow.com/a/5836522/61811</a>)</div>
</div>
<div class="paragraph">
<p>This defines a view frustum in the near, far, top, right, bottom and left planes.
This view frustum can also be used by the GPU to clip any parts of the 3D scene that are not visible.
If the points are outside of this view frustum then they can be ignored by the GPU.</p>
</div>
<div class="paragraph">
<p>To do this we want our projected points inside the view frustum to map to values defined by Metals clip space (as we will see later this is what we want to end up with and output from our Vertex Shader):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/clipspace.jpg" alt="clipspace">
</div>
<div class="title">Metal clip space (<a href="https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives" class="bare">https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives</a>)</div>
</div>
<div class="paragraph">
<p>I&#8217;m not going to go in how to derive the math here, there are many resources online to look at, but for our purposes the math we will use looks like:</p>
</div>
<div class="listingblock">
<div class="title">Math.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">static</span> <span class="kd">func</span> <span class="nf">makePerspective</span><span class="p">(</span>
  <span class="n">fovyDegrees</span> <span class="nv">fovy</span><span class="p">:</span> <span class="kt">Float</span><span class="p">,</span>
  <span class="nv">aspectRatio</span><span class="p">:</span> <span class="kt">Float</span><span class="p">,</span>
  <span class="nv">nearZ</span><span class="p">:</span> <span class="kt">Float</span><span class="p">,</span>
  <span class="nv">farZ</span><span class="p">:</span> <span class="kt">Float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Mat4</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">ys</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nf">tanf</span><span class="p">(</span><span class="kt">Math</span><span class="o">.</span><span class="nf">toRadians</span><span class="p">(</span><span class="n">fovy</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">xs</span> <span class="o">=</span> <span class="n">ys</span> <span class="o">/</span> <span class="n">aspectRatio</span>
  <span class="k">let</span> <span class="nv">zs</span> <span class="o">=</span> <span class="n">farZ</span> <span class="o">/</span> <span class="p">(</span><span class="n">nearZ</span> <span class="o">-</span> <span class="n">farZ</span><span class="p">)</span>
  <span class="k">return</span> <span class="kt">Mat4</span><span class="p">([</span>
    <span class="kt">Vec4</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">),</span>
    <span class="kt">Vec4</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">),</span>
    <span class="kt">Vec4</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="kt">Vec4</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="n">zs</span> <span class="o">*</span> <span class="n">nearZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">])</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As you can see this function is dependant on the aspect ratio of the screen, so if that changes we need to make sure that we update this calculation.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_summary">Summary</h3>
<div class="paragraph">
<p>In summary, to take a local point in 3D and end up with it transformed to values we can use to render to the screen we perform (from right to left):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>LocalToClipSpace = T<sub>projection</sub> * T<sub>view</sub> * T<sub>model</sub></p>
</div>
</div>
</div>
<div class="paragraph">
<p>I&#8217;ve skipped over a lot of the details here but I would recommend this book if you want to dive more into the math around this: <a href="https://www.essentialmath.com/book.htm">Essential Math for Games Programmers</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_metal">Metal</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_what_is_metal">What is Metal?</h3>
<div class="quoteblock">
<blockquote>
Metal is a low-level, low-overhead hardware-accelerated 3D graphic and compute shader application programming interface (API) developed by Apple Inc., and which debuted in iOS 8. Metal combines functions similar to OpenGL and OpenCL under one API.
</blockquote>
</div>
<div class="paragraph">
<p>Source: <a href="https://en.wikipedia.org/wiki/Metal_(API)">Wikipedia</a></p>
</div>
<div class="paragraph">
<p>You use the Metal API in your macOS, iOS or tvOS apps via Swift or Objective-C.
The API lets you interact and send commands to the GPU.
Along with the API you also need to write some Metal Shaders, this is done in the <a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">Metal Shader Language</a>.</p>
</div>
<div class="paragraph">
<p>Apple&#8217;s aim with Metal was to replace OpenGL with a single API they owned and could control the roadmap for, that also allowed them to remove a lot of the overhead that comes with a cross platform framework with a long legacy.</p>
</div>
<div class="paragraph">
<p>Whether you want or need to use Metal depends on your use case.
Obviously if you are looking for a cross platform framework that could be used eventually on something like Android, Metal is not the way to go.
However if you are Apple focussed or building a graphical abstraction where Metal might be one of the compile targets Metal will help you get the absolute highest performance for your graphical application.</p>
</div>
<div class="paragraph">
<p>As well as Metal, Apple also has <a href="https://developer.apple.com/documentation/scenekit">SceneKit</a> another 3D graphics framework you can use to create content in your 3D app.
This might be a good choice and it is now built on top of Metal, but being another level of abstraction above Metal you may come across limitations in the framework that hinder you or the apps performance.
Building on the absolute lowest level gives you the ultimate freedom, however I have found SceneKit to be a really intuitive and fun framework to use for simple 3D apps.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_metalkit">What is MetalKit?</h3>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/metalkit">MetalKit</a> is a framework that provides some helper classes that simply some common Metal use cases.</p>
</div>
<div class="paragraph">
<p>It mainly provides an easy way to <a href="https://developer.apple.com/documentation/metalkit/mtktextureloader">load textures</a>, handle loading 3D models from <a href="https://developer.apple.com/documentation/modelio">Model I/O</a> and provides a <a href="https://developer.apple.com/documentation/metalkit/mtkview">MTKView</a> class that makes creating a view capable of rendering Metal content very easy.</p>
</div>
</div>
<div class="sect2">
<h3 id="_shaders">Shaders</h3>
<div class="paragraph">
<p>Metal is a low level framework, most of the magic actually comes from running your code not on the CPU but the GPU.
Just like you can compile and run code on your CPU, you can write programs and compile and run them on the GPU instead, these are referred to as shaders.</p>
</div>
<div class="paragraph">
<p>A GPU is a highly specialized piece of hardware which is massively parallelized to process complex 3D scenes (you can also run non graphical workloads on the GPU via compute shaders but we are not going to cover that here).</p>
</div>
<div class="paragraph">
<p>There are two main types of shaders you will use to render 3D content, the vertex shader and the fragment shader.
The job of the vertex shader is to take 3D points in local space for a model and transform them into clip space (as we talked about earlier).
Once the GPU has the transformed points, it can take some extra information such as how the points are connected together to make triangles and determine which points on the screen should be drawn (rasterization).</p>
</div>
<div class="paragraph">
<p>Once we have individual pixels, we can call the Fragment shader that will then determine what is the final color of the pixel, usually based on some lighting and materials associated with the model and scene.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/renderpipeline.jpg" alt="renderpipeline">
</div>
<div class="title">A basic render pipeline (<a href="https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives">Source: Apple</a>)</div>
</div>
<div class="paragraph">
<p>The main process here is to first create a buffer in code, basically a contiguous chunk of memory, fill that with 3D information e.g. [x0, y0, z0, x1, y1, z1, &#8230;&#8203;] then send those values plus textures and other vertex attributes (color, normals) and the other matrices we looked at T<sub>Model</sub>, T<sub>View</sub>, T<sub>Projection</sub> to the GPU.
Once on the GPU, each vertex information will be passed to the vertex function, it then applies the transforms ot the points and returns them to the GPU for rasterization.
Finally the rasterized points end up passed in to the Fragment shader where we decide the final color for the pixel.
This information is then written to a frame buffer and eventually rendered to the screen.</p>
</div>
<div class="paragraph">
<p>Metal shaders use the <a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">Metal Shader Language</a>.
MSL is based on C++14 with certain modifications and restrictions.</p>
</div>
<div class="paragraph">
<p>An example of a simple vertex and fragment shader that renders models with a solid color is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="msl">#include &lt;metal_stdlib&gt;
#include &lt;simd/simd.h&gt;

using namespace metal;

struct VertexIn { <i class="conum" data-value="1"></i><b>(1)</b>
  float3 position [[attribute(0)]]; <i class="conum" data-value="2"></i><b>(2)</b>
  float4 color [[attribute(1)]];
};

struct VertexOut { <i class="conum" data-value="3"></i><b>(3)</b>
  float4 position [[position]]; <i class="conum" data-value="4"></i><b>(4)</b>
  float4 color;
};

struct Uniforms { <i class="conum" data-value="5"></i><b>(5)</b>
  float4x4 modelMatrix;
  float4x4 viewProjectionMatrix;
};

vertex VertexOut simple_vertex( <i class="conum" data-value="6"></i><b>(6)</b>
  const VertexIn vIn [[ stage_in ]], <i class="conum" data-value="7"></i><b>(7)</b>
  const device Uniforms&amp; uniforms [[ buffer(0) ]] {  <i class="conum" data-value="8"></i><b>(8)</b>

  VertexOut vOut;
  vOut.position = uniforms.viewProjectionMatrix * uniforms.modelMatrix * float4(vIn.position, 1.0); <i class="conum" data-value="9"></i><b>(9)</b>
  vOut.color = vIn.color;
  return vOut;
}

fragment float4 simple_fragment(VertexOut fragIn [[stage_in]]) { <i class="conum" data-value="10"></i><b>(10)</b>
  return fragIn.color; <i class="conum" data-value="11"></i><b>(11)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You define a structure to tell the vertex shader how the incoming vertex data is structured. This needs to match the exact structure of the data that you place into the buffer in the Swift side of the code.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>You specify using special syntax which tells the shader which part of the input vertex buffer this attribute is mapped to.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You need to define a structure telling the vertex shader what data it will output.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>You need to tell Metal which parameter is the position parameter since that is needed for rasterization.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The Uniforms structure is extra data that is used to process the vertices. Think of it as data that can be shared across all vertices.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This is the vertex shader, notice how you have to prefix the function with "vertex"</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><a id="stage_in"></a> just specifies that this parameter is where your vertex data will be mapped to. stage_in means that Metal will piece together the VertexIn struct from whereever you told it the vertex data was going to come from inside a MTLVertexDescriptor object (this will make more sense later).</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>[[ buffer(0) ]] tells the shader that you mapped the vertex data to buffer slot 0. You can map many buffers at once e.g. buffer(1), buffer(2) etc. all with different information.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Here is where we transform the vertices from local space to clip space.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>This is the fragment shader. Notice how it is prefixed with "fragment"</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>This is a simple shader that just passes through the pixel color. Normally you do something more complicated here like calculate lighting or add some special effects. Notice how even though we only specified a color at the vertices somehow we got a color for the pixel. This is because the rasterizer will interpolate the vertex values when it is rasterizing the triangles so the color of each pixel is a linear combination of the color in the vertices.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_core_types">Core Types</h3>
<div class="paragraph">
<p>There are a number of core types you will interact with. They may initially look a bit verbose but they are actually pretty simple once you get the basic principles of Metal.</p>
</div>
<div class="sect3">
<h4 id="_mtldevice">MTLDevice</h4>
<div class="paragraph">
<p>A <a href="https://developer.apple.com/documentation/metal/mtldevice">MTLDevice</a> is a protocol that defines an abstraction around the GPU.
It is used to create resources such as buffers to store 3D vertices, send drawing commands to the GPU, basically any interaction with the GPU is done through this interface.</p>
</div>
<div class="paragraph">
<p>This is the first object you will want to create and then keep a reference to it for the lifetime of your application.
You can create multiple devices if you have multiple GPUs in your computer, but for most apps you will just have one main device.</p>
</div>
<div class="paragraph">
<p>Creating the device is very simple, call <a href="https://developer.apple.com/documentation/metal/1433401-mtlcreatesystemdefaultdevice">MTLCreateSystemDefaultDevice</a> and verify that a device could be created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">guard</span> <span class="k">let</span> <span class="nv">device</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Metal is not supported"</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mtlcommandqueue">MTLCommandQueue</h4>
<div class="paragraph">
<p>In order to draw anything on the screen we have to be able to send commands to the GPU.
A <a href="https://developer.apple.com/documentation/metal/mtlcommandqueue">MTLCommandQueue</a> lets you send commands to the GPU.
You create command buffers, which just contain multiple GPU instructions, then submit the buffers to the command queue.</p>
</div>
<div class="paragraph">
<p>For most apps you will just need one command queue, however you can create multiple queues if you have different types of work you are submitting to the GPU, such as one queue for real-time rendering and one queue compute processing (running non visual code on the GPU).</p>
</div>
<div class="paragraph">
<p>To create a queue you simply call <a href="https://developer.apple.com/documentation/metal/mtldevice/1433388-newcommandqueue">newComandQueue</a> on the device:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">guard</span> <span class="k">let</span> <span class="nv">commandQueue</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeCommandQueue</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As with the MTLDevice instance, you will want to just create one command queue at the beginning of your app, then keep a reference to it for the entire lifetime of your application.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mtkview">MTKView</h4>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/metalkit/mtkview">MTKView</a> is part of <a href="https://developer.apple.com/documentation/metalkit">MetalKit</a> and provides a friendly wrapper around setting up a view that can be used to render Metal content.
The view automatically manages a CAMetalLayer instance to draw to and also provides the mechanism to inform the app that the view needs to be re-rendered, either automatically 60 times a second or on demand when the code explicitly says to update.</p>
</div>
<div class="paragraph">
<p>The main things you will do with MTKView are specifying the device, the clear color to use when clearing the screen each frame, along with the format to use for the output buffer and depth stencil (used to determine if parts of an object are visible or not during rendering).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">mtkView</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
<span class="n">mtkView</span><span class="o">.</span><span class="n">clearColor</span> <span class="o">=</span> <span class="kt">MTLClearColor</span><span class="p">(</span>
  <span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
  <span class="nv">green</span><span class="p">:</span> <span class="mf">104.0</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span>
  <span class="nv">blue</span><span class="p">:</span> <span class="mf">55.0</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span>
  <span class="nv">alpha</span><span class="p">:</span> <span class="mf">1.0</span>
<span class="p">)</span>

<span class="n">mtkView</span><span class="o">.</span><span class="n">colorPixelFormat</span> <span class="o">=</span> <span class="o">.</span><span class="n">bgra8Unorm_srgb</span>
<span class="n">mtkView</span><span class="o">.</span><span class="n">depthStencilPixelFormat</span> <span class="o">=</span> <span class="o">.</span><span class="n">depth32Float</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to get the frame and view size change notification you need to implement the MTKViewDelegate protocol.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mtkviewdelegate">MTKViewDelegate</h4>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/metalkit/mtkviewdelegate">MTKViewDelegate</a> is a simple protocol consisting of two methods:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://developer.apple.com/documentation/metalkit/mtkviewdelegate/1536015-mtkview">mtkView(_:drawableSizeWillChange:):</a></dt>
<dd>
<p>This will be called when the view changes size. You can add code here to update any classes you have that might depend on the size or aspect ratio of the MTKView.</p>
</dd>
<dt class="hdlist1"><a href="https://developer.apple.com/documentation/metalkit/mtkviewdelegate/1535942-draw">draw(in:)</a></dt>
<dd>
<p>This function by default will be called once per frame.
This is where you will put all of your drawing code to render your scene every frame and update animations etc.
By default this method is called 60 times a second, based on the <a href="https://developer.apple.com/documentation/metalkit/mtkview/1536027-preferredframespersecond">preferredFramesPerSecond</a> property of MKTView.
You can also configure if the method should only be called is the user explicitly indicates the view has changed by calling setNeedsDisplay(), see <a href="https://developer.apple.com/documentation/metalkit/mtkview/1535993-enablesetneedsdisplay">this</a> property for more detail.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_mtldrawable">MTLDrawable</h4>
<div class="paragraph">
<p>A <a href="https://developer.apple.com/documentation/metal/mtldrawable">MTLDrawable</a> provides a MTLTexture instance that can be used as a render target to present the output from your shaders.
Basically this is the output where your shaders will write the final pixel values to then Metal will show this buffer on the screen.</p>
</div>
<div class="paragraph">
<p>Once you are ready to show the drawable on the screen you call the <a href="https://developer.apple.com/documentation/metal/mtldrawable/1470284-present">present()</a> method that indicates this drawable should be shown on the screen as soon as all commands in the command queue relating to this drawable have been executed.</p>
</div>
<div class="paragraph">
<p>Each frame you will want to get a reference to a drawable that can be used to render new content to.
The MTKView has a <a href="https://developer.apple.com/documentation/metalkit/mtkview/1535971-currentdrawable">currentDrawable</a> property that will return a drawable to you that can be used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">guard</span> <span class="k">let</span> <span class="nv">drawable</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">currentDrawable</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">commandBuffer</span> <span class="o">=</span> <span class="n">commandQueue</span><span class="o">.</span><span class="nf">makeCommandBuffer</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Send drawing commands to the GPU</span>

<span class="c1">// Indicate the drawable should present its content ASAP after processing commands</span>
<span class="n">commandBuffer</span><span class="o">.</span><span class="nf">present</span><span class="p">(</span><span class="n">drawable</span><span class="p">)</span>
<span class="n">commandBuffer</span><span class="o">.</span><span class="nf">commit</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mtlrenderpipelinestate_mtlrenderpipelinedescriptor">MTLRenderPipelineState / MTLRenderPipelineDescriptor</h4>
<div class="paragraph">
<p>Before we discuss these objects, first there is a common pattern used in the Metal API that we should quickly touch on that will make the API a lot clearer.
A lot of the time when you want to create a FooObject, you first create a FooDescriptor and populate the descriptor with all of the required configuration information, then pass the FooDescriptor to the method used to create the object.
The descriptor can be though of as a blueprint on how to create the object.
Once you have created the object the descriptor is no longer needed, you could update it and create a new object with it if you had several objects that were similar, but generally once you create the object the descriptor can be discarded.</p>
</div>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/metal/mtlrenderpipelinestate">MTLRenderPipelineState</a> main purpose is to contain information about which vertex + fragment shader to use when you are issuing drawing commands to the GPU.
For example, you may have one set of shaders that renders models as a <a href="https://en.wikipedia.org/wiki/Cel_shading">Toon Shader</a> and another set of shaders that renders models using realistic materials found in the world, <a href="https://en.wikipedia.org/wiki/Physically_based_rendering">Physically Based Rendering</a> shaders.
In this case you would have multiple MTLRenderPipeline instances.
Before you tell the GPU to draw any triangles, you set the desired MTLRenderPipelineState as being the active state then render the model.</p>
</div>
<div class="paragraph">
<p>Once again, as we saw with MTLDevice and MTLCommandQueue you will want to create all of your MTLRenderPipelineState objects as soon as possible, because they could include an expensive shader compilation, then hang on to references to these states throughout the lifetime of the application.</p>
</div>
<div class="paragraph">
<p>The <a href="https://developer.apple.com/documentation/metal/mtlrenderpipelinedescriptor">MTLRenderPipelineDescriptor</a> type is used to specify which vertex and fragment shader to use when creating the state object.
At it&#8217;s simplest level you can create it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">guard</span> <span class="k">let</span> <span class="nv">defaultLibrary</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeDefaultLibrary</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Unable to load Metal shaders"</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">fragment</span> <span class="o">=</span> <span class="n">defaultLibrary</span><span class="o">.</span><span class="nf">makeFunction</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"fragment_function"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Did not find fragment function"</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">vertex</span> <span class="o">=</span> <span class="n">defaultLibrary</span><span class="o">.</span><span class="nf">makeFunction</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"vertex_function"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Did not find vertex function"</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">descriptor</span> <span class="o">=</span> <span class="kt">MTLRenderPipelineDescriptor</span><span class="p">()</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">vertexFunction</span> <span class="o">=</span> <span class="n">vertex</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">fragmentFunction</span> <span class="o">=</span> <span class="n">fragment</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelFormat</span> <span class="o">=</span> <span class="n">metalKitView</span><span class="o">.</span><span class="n">colorPixelFormat</span> <i class="conum" data-value="4"></i><b>(4)</b>

<span class="c1">// We will cover this later, but this specifies how the vertex data is laid out in memory.</span>
<span class="c1">// descriptor.vertexDescriptor = vertexDescriptor</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">state</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeRenderPipelineState</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">descriptor</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Unable to compile shaders"</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>All .metal files in your xcode project are compiled into a default library object that you then access using the makeDefaultLibrary function.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>fragment_function is the name of your fragment shader in the .metal file.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>vertex_function is the name of your vertex shader in the .metal file.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>You will have previously set the format for the output buffer earlier in your code.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_mtlcommandbuffer">MTLCommandBuffer</h4>
<div class="paragraph">
<p>Generally you will create a new command buffer at the beginning of a frame and fill it with commands to send to the GPU.
You then commit the buffer and after that can release the reference to the object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="c1">// At the start of a new frame</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">commandBuffer</span> <span class="o">=</span> <span class="n">commandQueue</span><span class="o">.</span><span class="nf">makeCommandBuffer</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Create some commands and add to the buffer e.g. draw triangles etc.</span>

<span class="c1">// Commit the commands to the GPU</span>
<span class="n">commandBuffer</span><span class="o">.</span><span class="nf">commit</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mtlrenderpassdescriptor">MTLRenderPassDescriptor</h4>
<div class="paragraph">
<p>The <a href="https://developer.apple.com/documentation/metal/mtlrenderpassdescriptor">MTLRenderPassDescriptor</a> contains information on which render targets should be used to render new content to.</p>
</div>
<div class="paragraph">
<p>Using MTKView from the MetalKit framework makes this easy.
We don&#8217;t have to configure this object ourselves, we can just call the currentRenderPassDescriptor property on MTKView and it will return a descriptor to us that already has a drawable set on the color attachment.</p>
</div>
<div class="paragraph">
<p>Another important setting is the load and store action.
These specify what should happen at the start of a rendering pass and what should happen to the pixel values after the content has been displayed on the screen.
There are three values for the load action:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">clear</dt>
<dd>
<p>The existing content of the buffer should be overwritten. The value you set in the MTKVew clearColor property will be set on every pixel.</p>
</dd>
<dt class="hdlist1">dontCare</dt>
<dd>
<p>Each pixel in the buffer can have any value we don&#8217;t care what they are. This is an option you can use if your code is going to write to every pixel in the buffer.</p>
</dd>
<dt class="hdlist1">load</dt>
<dd>
<p>The existing content of the buffer should be preserved for the start of this pass.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Mostly you probably just want to use clear to clear out the contents.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mtlrenderpasscommandencoder">MTLRenderPassCommandEncoder</h4>
<div class="paragraph">
<p>Once you have configured your render pass descriptor you can create a MTLRenderPassCommandEncoder.
This is the final piece of the rendering puzzle.
So we have gone from setting up our device, a command queue, created a new buffer to put our commands in, then finally chosen which buffers we should write to in our RenderPassDescriptor, now we want to send actual draw commands to the GPU.</p>
</div>
<div class="paragraph">
<p>The render pass encoder will typically set:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Which vertex + fragment shader you want to use</p>
</li>
<li>
<p>Bind the vertex buffers with vertex data to particular buffers so they can be accessed by the shaders</p>
</li>
<li>
<p>Bind any additional buffers, like uniform buffers passing projection matrices etc.</p>
</li>
<li>
<p>Issue the actual draw call, that specifies how many primitives to draw and what kind of primitives they are, triangles, lines.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Metal is very efficient due to all the batching of the commands, so you can issue tens of thousands of draw calls (depending on the complexity of the shaders) if desired. Ideally though you keep this number as low as possible.</p>
</div>
<div class="paragraph">
<p>An example of setting properties on the render pass encoder is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">guard</span> <span class="k">let</span> <span class="nv">encoder</span> <span class="o">=</span> <span class="n">commandBuffer</span><span class="o">.</span><span class="nf">makeRenderCommandEncoder</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">renderPassDescriptor</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="n">encoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">uniformBuffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">encoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">encoder</span><span class="o">.</span><span class="nf">setRenderPipelineState</span><span class="p">(</span><span class="n">renderPipelineState</span><span class="p">)</span>
<span class="n">encoder</span><span class="o">.</span><span class="nf">setFragmentTexture</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">encoder</span><span class="o">.</span><span class="nf">setFragmentSamplerState</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">encoder</span><span class="o">.</span><span class="nf">drawPrimitives</span><span class="p">(</span>
  <span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">triangles</span><span class="p">,</span>
  <span class="nv">vertexStart</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nv">vertexCount</span><span class="p">:</span> <span class="n">vertexCount</span><span class="p">,</span>
  <span class="nv">instanceCount</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">)</span>

<span class="n">encoder</span><span class="o">.</span><span class="nf">endEncoding</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mtltexture_mtktextureloader">MTLTexture / MTKTextureLoader</h4>
<div class="paragraph">
<p>Textures are a very important of any 3D app.
Once we have an MTLTexture we can bind it to our fragment shader and access it from the fragment shader to use to color the output pixels.</p>
</div>
<div class="paragraph">
<p>For example, here we can see the basic 3D model of a tank without and texturing, then the same model with texturing applied below.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tankwireframe.jpg" alt="tankwireframe">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tanktextured.jpg" alt="tanktextured">
</div>
<div class="title">Textured Tank (<a href="https://sketchfab.com/3d-models/metal-slug-rebel-tank-comic-style-1b06956e7ecd407693e91645f07d25ac">Sketchfab</a>)</div>
</div>
<div class="paragraph">
<p>How this works is that for each vertex as well as specifying a 3D x,y,z value we also specify an offset into a texture that should be used to texture that particular part of the model, known as texture coordinates (u, v).</p>
</div>
<div class="paragraph">
<p>In Metal we can specify texture coordinates in either pixel values or normalized values.
Normalized texture coordinates are simply values from 0 to 1, with the top left being (0, 0) and the bottom right being (1,1).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/normalizedtexcoords.jpg" alt="normalizedtexcoords">
</div>
</div>
<div class="paragraph">
<p>It&#8217;s simple to load a texture using the <a href="https://developer.apple.com/documentation/metalkit/mtktextureloader">MTKTextureLoader</a> class from MetalKit.
There are a number of options to load from a URL, or from the app bundle.</p>
</div>
<div class="listingblock">
<div class="title">Example of loading a texture from the main bundle.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">texLoader</span> <span class="o">=</span> <span class="kt">MTKTextureLoader</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="n">device</span><span class="p">)</span>

<span class="k">return</span> <span class="k">try</span><span class="p">?</span> <span class="n">texLoader</span><span class="o">.</span><span class="nf">newTexture</span><span class="p">(</span>
  <span class="nv">name</span><span class="p">:</span> <span class="s">"myImage"</span><span class="p">,</span>
  <span class="nv">scaleFactor</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
  <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
  <span class="nv">options</span><span class="p">:</span> <span class="p">[:]</span>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once we have the MTLTexture instance there is one more piece we need, a sampler.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mtlsamplerdescriptor_mtlsamplerstate">MTLSamplerDescriptor / MTLSamplerState</h4>
<div class="paragraph">
<p>Once you have a texture you need to tell Metal how it should calculate the pixel color for different situations.
For example is the caller going to pass normalized texture coordinates (0,0 &#8594; 1,1) to access the pixels or actual pixel offsets (100, 250).
What should happen if the caller passes in a texture coordinate outside of the texture bounds e.g. (1.25, 0.9).
How should the GPU calculate pixel values if the texture is much larger or smaller than the size it is being displayed on the screen and the texture has to be scaled up or down.</p>
</div>
<div class="paragraph">
<p>All these settings we specify in a MTLSamplerDescriptor then use that to create the MTLSamplerState.</p>
</div>
<div class="listingblock">
<div class="title">Creating a new sampler state</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">samplerDescriptor</span> <span class="o">=</span> <span class="kt">MTLSamplerDescriptor</span><span class="p">()</span>
<span class="n">samplerDescriptor</span><span class="o">.</span><span class="n">normalizedCoordinates</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">samplerDescriptor</span><span class="o">.</span><span class="n">minFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
<span class="n">samplerDescriptor</span><span class="o">.</span><span class="n">magFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
<span class="n">samplerDescriptor</span><span class="o">.</span><span class="n">mipFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">sampler</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeSamplerState</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">samplerDescriptor</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You will want to keep the MTLSamplerState object around as long as you need the MTLTextureInstance. You can also use the same sampler with multiple textures if they all have the same settings.</p>
</div>
<div class="paragraph">
<p>Once you have the sampler state, you will want to pass both the texture and the sampler to the fragment shader, using your MTLRenderPassEncoder instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">encoder</span><span class="o">.</span><span class="nf">setFragmentTexture</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">encoder</span><span class="o">.</span><span class="nf">setFragmentSamplerState</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we bind both the texture and sampler to slots 0, then in the fragment shader you can access them both to choose a pixel value e.g.</p>
</div>
<div class="listingblock">
<div class="title">Example fragment shader in Metal Shader Language</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="msl">fragment float4 texture_fragment( <i class="conum" data-value="1"></i><b>(1)</b>
  VertexOut fragIn [[stage_in]], <i class="conum" data-value="2"></i><b>(2)</b>
  texture2d&lt;float, access::sample&gt; diffuseTexture [[texture(0)]], <i class="conum" data-value="3"></i><b>(3)</b>
  sampler diffuseSampler [[sampler(0)]]) { <i class="conum" data-value="4"></i><b>(4)</b>

  return diffuseTexture.sample(diffuseSampler, fragIn.tex).rgba; <i class="conum" data-value="5"></i><b>(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You specify a fragment shader by prefixing the function with the "fragment" keyword</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The input to the fragment shader is the output from the Vertex shader, which has been interpolated by the GPU so that the values in the vertex are interpolated across the rasterized values sent to the pixel shader.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Our texture is bound to texture slot 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Our sampler is bound to sampler slot 0</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We access the pixel value of the texture by passing in the sampler and the texture coordinates (u,v) to the sample method.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_memory_layout">Memory Layout</h3>
<div class="sect3">
<h4 id="_size_stride_alignment">Size / Stride / Alignment</h4>
<div class="paragraph">
<p>Before we talk about the last type MTLVertexDescriptor, it is important that we understand how Swift + Metal layout the underlying bytes for the data that we use to communicate between the Swift code and the Vertex shader.</p>
</div>
<div class="paragraph">
<p>Since we are creating raw blocks of memory in our buffers and populating them with values, we need to be very sure that the layout of the bytes we write in to the buffer in Swift matches up with what the Vertex shader expects for the layout of the input structs.
If these don&#8217;t line up properly you will end up with garbage output on your screen.</p>
</div>
<div class="paragraph">
<p>In Swift we have the <a href="https://developer.apple.com/documentation/swift/memorylayout">MemoryLayout</a> enum that can be used to query how different types are laid out in memory.
There are three different terms to discuss when talking about memory:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Size</dt>
<dd>
<p>Size represents the total number of bytes that must be copied in order to preserve the value of the item.
For example, if you have an instance of a Float, a Float requires 4 bytes in memory, therefore if you have a pointer to the start of the float value you need to copy 4 bytes from the start in order to transfer it somewhere else.</p>
</dd>
<dt class="hdlist1">Stride</dt>
<dd>
<p>Stride represents the total number of bytes from the start of one instance of a type to the next in a contiguous block of memory like an array.
So if we have a type T and an array of instances e.g [T0, T1, T2 &#8230;&#8203;] for reasons we see below if you simply sum up all the sizes of the fields in the type that might not be the same as the memory offset of T1, due to extra empty padding being added between the fields of the type.
It is true that stride(T) &gt;= size(T).</p>
</dd>
<dt class="hdlist1">Alignment</dt>
<dd>
<p>When the computer reads or writes values it does it in chunks of memory, maybe 4 bytes, 8 bytes or more.
Most CPUs can only handle reading/writing data on these chunk boundaries, you can&#8217;t write a value across a boundary.
For example, if you have an Int that is 4 bytes, we could write it at memory address 0, or memory address 4, but if we were to try to write the int starting at memory address 2 this would potentially cause a crash across a chunk boundary.
Therefore when writing values to memory we need to know the alignment requirements of the type to see what addresses we are allowed to write to.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Let us look at an example to clarify these terms.
Image we have a struct that contains an Int and a Bool, looking at the size/stride/alignment values for Int and Bool individually we see that a Bool takes 1 byte to store and that an Int (in this case a 64bit int) takes 8 bytes.
The size, stride and alignment values are all the same.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="o">&gt;.</span><span class="n">size</span>       <span class="c1">// 1</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="o">&gt;.</span><span class="n">stride</span>     <span class="c1">// 1</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="o">&gt;.</span><span class="n">alignment</span>  <span class="c1">// 1</span>

<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">size</span>        <span class="c1">// 8</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">stride</span>      <span class="c1">// 8</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;.</span><span class="n">alignment</span>   <span class="c1">// 8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s define an Account struct that contains an amount and an active field.
Looking at the values above, we should be able to add up the Int + Bool values and get a size of 9 bytes for this struct, but what about the stride and alignment values?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">Account</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">amount</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="k">let</span> <span class="nv">active</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Account</span><span class="o">&gt;.</span><span class="n">size</span>       <span class="c1">// 9</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Account</span><span class="o">&gt;.</span><span class="n">stride</span>     <span class="c1">// 16</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Account</span><span class="o">&gt;.</span><span class="n">alignment</span>  <span class="c1">// 8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the stride is 16 bytes and the alignment is 8.
What this means is that if we have an array of Account structs and wanted to copy their memory to another location, we couldn&#8217;t just say copy (9 * numberItems) bytes, we would end up not copying all the bytes but infact we have to copy (16 * numberItems) bytes.</p>
</div>
<div class="paragraph">
<p>This is how an array of Account would look like in memory:</p>
</div>
<div class="paragraph">
<p>I == Int Byte, B == Bool Byte, P == Padding Byte</p>
</div>
<div class="paragraph">
<p>I I I I I I I I B P P P P P P P I I I I I I I I B P P P P P P P &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The reason for the empty padding at the end of the first Account instance is that as we saw above the alignment of the Int type is 8, what that means is it can only be written to addresses that are divisible by 8.
As we can see if we try to write it to byte 10 then it will be spread across the chunk boundaries, hence it is written at the first available address that is divisible by 8 after the end of the first account instance, which is byte 16.</p>
</div>
<div class="paragraph">
<p>Now you can see why when you put items together in memory contiguously you might have holes that you need to take account of when copying.
In our case, we just need to always make sure that when we are copying data into our buffers we use the "stride" value not the "size".</p>
</div>
<div class="paragraph">
<p>So now what happens if we swap the order of the fields in our Account type?
Instead lets define it as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">Account</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">isActive</span><span class="p">:</span> <span class="kt">Bool</span>
  <span class="k">let</span> <span class="nv">amount</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Account</span><span class="o">&gt;.</span><span class="n">size</span>       <span class="c1">// 16</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Account</span><span class="o">&gt;.</span><span class="n">stride</span>     <span class="c1">// 16</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Account</span><span class="o">&gt;.</span><span class="n">alignment</span>  <span class="c1">// 8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Interesting, now the size changed to 16 instead of 8, but the stride stayed the same.
Remember that the size field says what the total number of bytes you need to copy to copy all of the data in a single instance of the struct.
What has happened is that the Bool alignment is 1 so it happily goes in byte 1 (it could be written to byte 2, 3, 4 , 5 etc and so on no problem).
However the Int alignment is 8, so it can&#8217;t be copied into byte 2, that is not divisible by 8, so we have to add some padding until we get to byte 8 to write it.</p>
</div>
<div class="paragraph">
<p>Now the layout in memory looks like:</p>
</div>
<div class="paragraph">
<p>I == Int Byte, B == Bool Byte, P == Padding Byte</p>
</div>
<div class="paragraph">
<p>B P P P P P P P I I I I I I I I B P P P P P P P I I I I I I I I &#8230;&#8203;</p>
</div>
</div>
<div class="sect3">
<h4 id="_floatn_packed_floatn">floatN / packed_floatN</h4>
<div class="paragraph">
<p>Given the information above, the main point to take away is to make sure when you are writing values to a buffer in Swift and defining structs in a shader, you understand the size, stride and alignment of the types you are using, on both sides.</p>
</div>
<div class="paragraph">
<p>There are some common types you will use in a shader, namely float2, float3, float4 for your position, normal, color, texture information etc.
These let you use vector float data like:</p>
</div>
<div class="listingblock">
<div class="title">Shaders.metal</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="msl">float3 position = float3(1.0, 2.0, 3.0);

// position.x, position.y, position.z</code></pre>
</div>
</div>
<div class="paragraph">
<p>At first glance you might think those structs are 8, 12 and 16 bytes long (2 * 4, 3 * 4, 4 * 4), seems reasonable, so you go ahead and define a struct in MSL that will be your incoming vertex data.</p>
</div>
<div class="listingblock">
<div class="title">Shaders.metal</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="msl">struct VertexIn {
  float3 position;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then on the Swift side, you create a vertex buffer and write individual floats in to the buffer.
To do this we will just create a struct with three floats in it that will then be copied in to the buffer.
We populate the buffer with some points that create a simple quad centered around (0,0,-5)</p>
</div>
<div class="listingblock">
<div class="title">Renderer.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">Vertex</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="kt">Float</span>

  <span class="kd">func</span> <span class="nf">toArray</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Float</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Define a simple quad with two triangles</span>
<span class="c1">// x1 ------ x2</span>
<span class="c1">// |         |</span>
<span class="c1">// |         |</span>
<span class="c1">// x0 ------ x3</span>
<span class="k">let</span> <span class="nv">halfSize</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="k">let</span> <span class="nv">z</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
<span class="k">let</span> <span class="nv">vertices</span><span class="p">:</span> <span class="p">[</span><span class="kt">Vertex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
  <span class="c1">// Triangle 0</span>
  <span class="kt">Vertex</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="o">-</span><span class="n">halfSize</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="o">-</span><span class="n">halfSize</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="n">z</span><span class="p">),</span>  <span class="c1">// x0</span>
  <span class="kt">Vertex</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">halfSize</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">halfSize</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="n">z</span><span class="p">),</span>    <span class="c1">// x2</span>
  <span class="kt">Vertex</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="o">-</span><span class="n">halfSize</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">halfSize</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="n">z</span><span class="p">),</span>   <span class="c1">// x1</span>

  <span class="c1">// Triangle 1</span>
  <span class="kt">Vertex</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="o">-</span><span class="n">halfSize</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="o">-</span><span class="n">halfSize</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="n">z</span><span class="p">),</span>  <span class="c1">// x0</span>
  <span class="kt">Vertex</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">halfSize</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="o">-</span><span class="n">halfSize</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="n">z</span><span class="p">),</span>   <span class="c1">// x3</span>
  <span class="kt">Vertex</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">halfSize</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">halfSize</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="n">z</span><span class="p">),</span>    <span class="c1">// x2</span>
<span class="p">]</span>

<span class="c1">// Put all the values in to one array</span>
<span class="k">var</span> <span class="nv">data</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Float</span><span class="p">]()</span>
<span class="k">for</span> <span class="n">vertex</span> <span class="k">in</span> <span class="n">vertices</span> <span class="p">{</span>
  <span class="n">data</span> <span class="o">+=</span> <span class="n">vertex</span><span class="o">.</span><span class="nf">toArray</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Create the buffer</span>
<span class="k">let</span> <span class="nv">size</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Vertex</span><span class="o">&gt;.</span><span class="n">stride</span> <span class="o">*</span> <span class="n">vertices</span><span class="o">.</span><span class="n">count</span>
<span class="n">meshBuffer</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeBuffer</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We then define a simple fragment shader that just returns the color red, and a simple vertex shader. Let&#8217;s define the vertex shader without using vertex descriptors this time:</p>
</div>
<div class="listingblock">
<div class="title">Shaders.metal</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="msl">struct VertexIn {
  float3 position; <i class="conum" data-value="1"></i><b>(1)</b>
};

struct VertexOut {
  float4 position [[position]];
};

vertex VertexOut vertexShader(
  const device VertexIn* vertices [[buffer(0)]], <i class="conum" data-value="2"></i><b>(2)</b>
  constant Uniforms &amp; uniforms [[buffer(1)]],
  unsigned int vid [[vertex_id]]) <i class="conum" data-value="3"></i><b>(3)</b>
{
  VertexOut vOut;
  float4 position = float4(vertices[vid].position, 1.0);
  vOut.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * position;
  return vOut;
}

fragment float4 fragmentShader(VertexOut in [[stage_in]]) {
  return float4(1.0, 0, 0, 1.0); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the definition of the vertex data in the vertex buffer</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Pointer to the vertex buffer</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The vertex id tells us which vertex in the buffer we should be operating on</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Simply return red for all the pixels</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is what we are expecting to see, a red quad in the middle of the screen:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/quad-good.jpg" alt="quad good">
</div>
</div>
<div class="paragraph">
<p>However when we run the code we end up seeing:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/quad-bad.jpg" alt="quad bad">
</div>
</div>
<div class="paragraph">
<p>That&#8217;s annoying. So what happened, somehow the x,y,z values we passed to the shader are incorrect.
We go back to the Metal Shader Language specification and look at the size/alignment values for the floatN types and we see:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/msl-float-memory.jpg" alt="msl float memory">
</div>
<div class="title">The size and alignment of the float vector types in Metal Shader Language (<a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">Source</a>)</div>
</div>
<div class="paragraph">
<p>Notice how the float3 actually has an alignment of 16 bytes, not 12 as we expected!
Even though it only exposes 3 floats in the code, it is expecting there is an extra byte of padding after each value.
Knowing this we go back to the code and change our struct to add an extra float value in the array:</p>
</div>
<div class="listingblock">
<div class="title">Renderer.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">Vertex</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="kt">Float</span>
  <span class="k">let</span> <span class="nv">padding</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">0.0</span>

  <span class="kd">func</span> <span class="nf">toArray</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Float</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">padding</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now everything renders as expected.</p>
</div>
<div class="paragraph">
<p>However instead of updating our Vertex structure in Swift, we could leave it as it was without the padding value and choose the packed_float3 type instead of float3 in our shader.
The packed_float3 type specifies we are expecting 3 float values for each item in the array without any padding.</p>
</div>
<div class="listingblock">
<div class="title">Shaders.metal</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="msl">struct VertexIn {
  packed_float3 position;
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_simd">SIMD</h4>
<div class="paragraph">
<p>A quick note on SIMD types.
Swift added native support for <a href="https://developer.apple.com/documentation/swift/simd">SIMD</a> data types.
SIMD stands for Single Instruction Multiple Data, they are hardware supported operations that allow multiple operations on data at once.</p>
</div>
<div class="paragraph">
<p>For example, if we had a 3D position stored as an x, y and z value, we could update the position by adding another value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="k">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="k">let</span> <span class="nv">z</span> <span class="o">=</span> <span class="mf">3.0</span>

<span class="k">let</span> <span class="nv">xDelta</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="k">let</span> <span class="nv">yDelta</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="k">let</span> <span class="nv">zDelta</span> <span class="o">=</span> <span class="mf">15.0</span>

<span class="k">let</span> <span class="nv">newX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xDelta</span>
<span class="k">let</span> <span class="nv">newY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">yDelta</span>
<span class="k">let</span> <span class="nv">newZ</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">zDelta</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we take each individual component and add some delta to it to create a new value.
However if we use SIMD types we can update all three values at once in a single CPU instruction</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">pos</span><span class="p">:</span> <span class="kt">SIMD3</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">delta</span><span class="p">:</span> <span class="kt">SIMD3</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">15.0</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">newPos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">delta</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As well as providing a performance benefit, it&#8217;s easier to code with the SIMD types to perform additions, multiplications and vector/matrix operations so you will see them used in the code.</p>
</div>
<div class="paragraph">
<p>Note that as well as Swift supporting SIMD, the types also match the floatN types we saw in our shaders, so you can directly copy an array of SIMD instances and reference them in your shader using floatN.
Also the SIMD3&lt;Float&gt; type also has a stride of 16 not 12 :)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">SIMD3</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;&gt;.</span><span class="n">size</span>       <span class="c1">// 16</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">SIMD3</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;&gt;.</span><span class="n">alignment</span>  <span class="c1">// 16</span>
<span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">SIMD3</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;&gt;.</span><span class="n">stride</span>     <span class="c1">// 16</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mtlvertexdescriptor">MTLVertexDescriptor</h3>
<div class="paragraph">
<p>A <a href="https://developer.apple.com/documentation/metal/mtlvertexdescriptor">MTLVertexDescriptor</a> instance lets us tell Metal how the data in the vertex buffer is laid out in memory so that in the vertex shader we can access it correctly.</p>
</div>
<div class="paragraph">
<p>As we have seen above we don&#8217;t actually need vertex descriptors to use Metal shaders, but they have some benefits in that you can change the layout and organization of your buffer data without affecting the vertex shader as much.
This lets you do things like use multiple individual buffers for data, one for positions, one for color, one for normals, instead of interleaving all of those values in one buffer.</p>
</div>
<div class="paragraph">
<p>The general idea is that the vertex descriptor says what data is in the buffer, what type of data it is float3, float4 etc then also which buffers the data is bound to.
This information lets us simplify the vertex shader code.</p>
</div>
<div class="paragraph">
<p>As an example, let&#8217;s take our simple quad above, now we define an MTLVertexDescriptor:</p>
</div>
<div class="listingblock">
<div class="title">Renderer.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">descriptor</span> <span class="o">=</span> <span class="kt">MTLVertexDescriptor</span><span class="p">()</span>

<span class="c1">// position x,y,z</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="o">.</span><span class="n">float3</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bufferIndex</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">layouts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Vertex</span><span class="o">&gt;.</span><span class="n">stride</span>

<span class="n">pipelineDescriptor</span><span class="o">.</span><span class="n">vertexDescriptor</span> <span class="o">=</span> <span class="n">descriptor</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now in our shaders we update the VertexIn struct to add an attribute that tells it which attribute in the descriptor it maps to.
We also update our vertex function definition to take a different input with a stage_in attribute.
This just tells the Metal shader compiler to automatically figure out from the descriptor how to piece together this struct, also no more vertex_id is needed.</p>
</div>
<div class="listingblock">
<div class="title">Shaders.metal</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="msl">struct VertexIn {
  float3 position [[attribute(0)]]; <i class="conum" data-value="1"></i><b>(1)</b>
};

struct VertexOut {
  float4 position [[position]];
};

vertex VertexOut vertexShader(
  const VertexIn vIn [[stage_in]],
  constant Uniforms &amp; uniforms [[buffer(1)]])
{
  VertexOut vOut;
  float4 position = float4(vIn.position, 1.0);
  vOut.position = uniforms.projectionMatrix * uniforms.modelViewMatrix * position;
  return vOut;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notice how we are using float3 and not packed_float3, this is because packed_floatN types are not allowed with attributes.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
There is one important thing to note here, which is the main take away.
On the Swift side we are passing in x,y,z,x,y,z,x,y,z in the vertex buffer, as we saw float3 in the shader is actually expecting 4 floats for each float3 instance (alignment of 16), so this code broke before but now it works, how?
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Turns out if you use a MTLVertexDescriptor and specify .float3 as the format, the Metal Shader can see that on the client side you are passing just 3 floats but the shader is expecting 4 under the hood and will just pad the last float with 0 automatically for you, magic!
This was a bit confusing when I first ran this code and expected it to break.
See the docs on <a href="https://developer.apple.com/documentation/metal/mtlvertexattributedescriptor/1516081-format">MTLVertexAttributeDescriptor</a> for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3d_engine">3D Engine</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we have a good understanding of all the pieces required to make a Metal app, let&#8217;s start creating the core types we will need to render something on the screen.</p>
</div>
<div class="sect2">
<h3 id="_disclaimer">Disclaimer</h3>
<div class="paragraph">
<p>There are an infinite number of ways you can write a 3D engine. The way I have laid out this code is not the "one true way", it&#8217;s one way but depending on your requirements, how performant you want your code to be, how maintainable you want the code etc, those will all factor in to how your code is laid out.
This code really gives you a starting point to where you can play around with Metal and start writing a more comprehensive and complex engine.</p>
</div>
<div class="paragraph">
<p>Once looking and playing around with this code I would really recommend trying out other 3D engines, they all have similar concepts but expose them in different ways. I actually really like <a href="https://developer.apple.com/documentation/scenekit">SceneKit</a>, it&#8217;s a very nice library build on top of Metal, but there are also plenty of other engines you can look at like <a href="https://docs.unity3d.com/Manual/index.html">Unity</a> or even things like <a href="https://docs.microsoft.com/en-us/previous-versions/windows/xna/bb197344(v=xnagamestudio.40)">XNA</a> (one of my favorites back in the day) that will help you learn more about 3D engine design.</p>
</div>
</div>
<div class="sect2">
<h3 id="_overview">Overview</h3>
<div class="paragraph">
<p>There are a couple of main types in our Engine.
How they all fit together is pretty simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Renderer
 |- Scene
   |- Camera
   |- Node
    |- Mesh?
     |- Material
      |- Texture?
    |- Node
    |- Node
     |- ...</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Renderer</dt>
<dd>
<p>An abstraction around the GPU. This class creates the device and command buffer and then create a single scene object that can be populated with content.</p>
</dd>
<dt class="hdlist1">Scene</dt>
<dd>
<p>The scene contains the root node which all content will be added to. Right now our scene is pretty bar bones but we will be adding extra functionality later.</p>
</dd>
<dt class="hdlist1">Node</dt>
<dd>
<p>A node contains a mesh. The node lets you specify where in the world the mesh should be rendered based on the rotation, scaling and translation transforms.
You can think of the mesh as just defining the model in local space, then the Node providing the information on how to take those local coordinates and move them in to the right place in the world.
It also can contain other child nodes to create a hierarchical structure.
The Mesh value is optional, a node doesn&#8217;t have to have a Mesh, it can simply be a container for other nodes.</p>
</dd>
<dt class="hdlist1">Mesh</dt>
<dd>
<p>A mesh contains all of the 3D vertices data needed to render the object. It also keeps a reference to the material used to render the model.</p>
</dd>
<dt class="hdlist1">Material</dt>
<dd>
<p>The material defines how the model should look on the screen. Should it be a solid color, texture etc. It&#8217;s really an abstraction around the vertex and fragment shader setup.</p>
</dd>
<dt class="hdlist1">Texture</dt>
<dd>
<p>A texture just contains the MTLTexture and MTLSamplerState objects and provides a helper method to load new textures.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_vec2_vec3_vec4_mat4">Vec2 / Vec3 / Vec4 / Mat4</h3>
<div class="paragraph">
<p>We need some simple vector and matrix classes to use in our engine.
Luckily Swift already has support for optimized Vector like types in the SIMD types.</p>
</div>
<div class="paragraph">
<p>These types however are pretty verbose, it gets old typing the generic version of these so I just type aliased them to shorter friendly names:</p>
</div>
<div class="listingblock">
<div class="title">Vec.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">typealias</span> <span class="kt">Vec2</span> <span class="o">=</span> <span class="kt">SIMD2</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;</span>
<span class="kd">typealias</span> <span class="kt">Vec3</span> <span class="o">=</span> <span class="kt">SIMD3</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;</span>
<span class="kd">typealias</span> <span class="kt">Vec4</span> <span class="o">=</span> <span class="kt">SIMD4</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Mat.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">typealias</span> <span class="kt">Mat4</span> <span class="o">=</span> <span class="n">float4x4</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Quaternion.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">typealias</span> <span class="kt">Quaternion</span> <span class="o">=</span> <span class="n">simd_quatf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the Mat file I also added some extension helper methods to make using the types a bit easier such as Mat4.scale(&#8230;&#8203;), Mat4.rotate(&#8230;&#8203;), Mat4.translate(&#8230;&#8203;).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of the time of writing there seems to be a bug in the swift compiler around the generic SIMD types that makes compilation times really long in certain cases, or you may see errors where the swift compiler throws up it&#8217;s hands and says it can&#8217;t figure out the types (never seen this in a compiler before). Hopefully Apple fixes this soon but if you see long compile times you might have to break down your statements into simpler parts of provide more type information to the compiler to help it out. <a href="https://forums.swift.org/t/has-type-checking-operators-on-generic-types-always-been-this-slow/23413" class="bare">https://forums.swift.org/t/has-type-checking-operators-on-generic-types-always-been-this-slow/23413</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_renderer">Renderer</h3>
<div class="paragraph">
<p>There are some objects, such as MTLDevice, MTLCommandQueue that are long living and need to be passed around the app. We are going to create a high level Renderer class that will help instantiate these objects and also keep track of them.</p>
</div>
<div class="paragraph">
<p>This is also going to be the class that implements the MTKViewDelegate protocol, so that we get updates when the view size changes (which is necessary to calculate our camera paraemeters later) and also the per frame callback we will use to kick off our rendering.</p>
</div>
<div class="listingblock">
<div class="title">Renderer.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">MetalKit</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">Renderer</span><span class="p">:</span> <span class="kt">NSObject</span> <span class="p">{</span>

  <span class="k">let</span> <span class="nv">device</span><span class="p">:</span> <span class="kt">MTLDevice</span>
  <span class="k">let</span> <span class="nv">library</span><span class="p">:</span> <span class="kt">MTLLibrary</span>
  <span class="k">let</span> <span class="nv">commandQueue</span><span class="p">:</span> <span class="kt">MTLCommandQueue</span>

  <span class="nf">init</span><span class="p">?(</span><span class="nv">mtkView</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">guard</span> <span class="k">let</span> <span class="nv">device</span> <span class="o">=</span> <span class="kt">MTLCreateSystemDefaultDevice</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"Metal is not supported"</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>

    <span class="k">guard</span> <span class="k">let</span> <span class="nv">library</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeDefaultLibrary</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"Failed to make default library"</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="o">.</span><span class="n">library</span> <span class="o">=</span> <span class="n">library</span>

    <span class="k">guard</span> <span class="k">let</span> <span class="nv">commandQueue</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeCommandQueue</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"Failed to make a command queue"</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="o">.</span><span class="n">commandQueue</span> <span class="o">=</span> <span class="n">commandQueue</span>

    <span class="k">self</span><span class="o">.</span><span class="n">mtkView</span> <span class="o">=</span> <span class="n">mtkView</span>
    <span class="n">mtkView</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>

    <span class="c1">// Specifies the pixel format to use for the buffer that will be rendered</span>
    <span class="c1">// to the screen</span>
    <span class="n">mtkView</span><span class="o">.</span><span class="n">colorPixelFormat</span> <span class="o">=</span> <span class="o">.</span><span class="n">bgra8Unorm_srgb</span>

    <span class="c1">// The format to use in the depth stencil. This is used to determine which parts</span>
    <span class="c1">// of a model are visible.</span>
    <span class="n">mtkView</span><span class="o">.</span><span class="n">depthStencilPixelFormat</span> <span class="o">=</span> <span class="o">.</span><span class="n">depth32Float</span>

    <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Renderer</span><span class="p">:</span> <span class="kt">MTKViewDelegate</span> <span class="p">{</span>

  <span class="kd">func</span> <span class="nf">mtkView</span><span class="p">(</span><span class="n">_</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">,</span> <span class="n">drawableSizeWillChange</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="k">in</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">MTKView</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_scene">Scene</h3>
<div class="paragraph">
<p>For any situation where we have more that one object to draw we will want some kind of container that we can add Nodes to and keep track of them.
The scene object will be this container.
We will add a root property to the Scene which will be the top level Node for all nodes in our scene.</p>
</div>
<div class="paragraph">
<p>There will only be one Scene instance and it will be created in the Renderer at creation time.</p>
</div>
<div class="paragraph">
<p>As well as storing the root Node instance, the Scene class will also store the clear color, this is the color we use for every new frame as the background.
Finally we also store the camera in the scene, the camera can be used to view the scene from different locations, just like a camera in the real world.</p>
</div>
<div class="listingblock">
<div class="title">Scene.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Metal</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">Scene</span> <span class="p">{</span>

  <span class="c1">/// The top level node in our entire scene</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">root</span> <span class="o">=</span> <span class="kt">Node</span><span class="p">()</span>

  <span class="c1">/// A camera used to view the content of the scene</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">camera</span><span class="p">:</span> <span class="kt">PerspectiveCamera</span>

  <span class="c1">/// A color that will be used as the background for every new frame</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">clearColor</span><span class="p">:</span> <span class="kt">MTLClearColor</span> <span class="o">=</span> <span class="kt">MTLClearColor</span><span class="p">(</span>
    <span class="nv">red</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="nv">green</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="nv">blue</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="nv">alpha</span><span class="p">:</span> <span class="mf">1.0</span>
  <span class="p">)</span>

  <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">camera</span> <span class="o">=</span> <span class="kt">PerspectiveCamera</span><span class="p">(</span>
      <span class="nv">origin</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
      <span class="nv">look</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="nv">up</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="nv">fovYDegrees</span><span class="p">:</span> <span class="mi">90</span><span class="p">,</span>
      <span class="nv">aspectRatio</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
      <span class="nv">zNear</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span>
      <span class="nv">zFar</span><span class="p">:</span> <span class="mf">1000.0</span>
    <span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">update</span><span class="p">(</span><span class="nv">time</span><span class="p">:</span> <span class="kt">Time</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">root</span><span class="o">.</span><span class="nf">updateInternal</span><span class="p">(</span><span class="nv">time</span><span class="p">:</span> <span class="n">time</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">render</span><span class="p">(</span>
    <span class="nv">time</span><span class="p">:</span> <span class="kt">Time</span><span class="p">,</span>
    <span class="nv">renderer</span><span class="p">:</span> <span class="kt">Renderer</span><span class="p">,</span>
    <span class="nv">encoder</span><span class="p">:</span> <span class="kt">MTLRenderCommandEncoder</span><span class="p">,</span>
    <span class="nv">uniformBuffer</span><span class="p">:</span> <span class="kt">MTLBuffer</span>
  <span class="p">)</span> <span class="p">{</span>

    <span class="n">root</span><span class="o">.</span><span class="nf">render</span><span class="p">(</span>
      <span class="nv">time</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
      <span class="nv">camera</span><span class="p">:</span> <span class="n">camera</span><span class="p">,</span>
      <span class="nv">renderer</span><span class="p">:</span> <span class="n">renderer</span><span class="p">,</span>
      <span class="nv">encoder</span><span class="p">:</span> <span class="n">encoder</span><span class="p">,</span>
      <span class="nv">parentTransform</span><span class="p">:</span> <span class="kt">Mat4</span><span class="o">.</span><span class="n">identity</span>
    <span class="p">)</span>

  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The update function will let us apply an update closure to each node that can be used to do per frame updates and animations.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_perspectivecamera">PerspectiveCamera</h3>
<div class="paragraph">
<p>We need a camera so that we can move around the scene and set properties such as the field of view to control how zoomed in or out the scene will be.
We will only support Perspective Projection in our engine, however adding Orthographic projection would be trivial by creating a Camera protocol that both a PerspectiveCamera and OrthographicCamera could implement.</p>
</div>
<div class="paragraph">
<p>The camera is pretty simple, it exposes a viewMatrix and projectionMatrix property, these matrices are recalculated if the user changes any of the property of the camera.
We then take these matrices and pass them to our vertex shader with a uniform buffer.</p>
</div>
<div class="listingblock">
<div class="title">PerspectiveCamera.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">final</span> <span class="kd">class</span> <span class="kt">PerspectiveCamera</span> <span class="p">{</span>

  <span class="k">var</span> <span class="nv">origin</span><span class="p">:</span> <span class="kt">Vec3</span> <span class="p">{</span> <span class="k">didSet</span> <span class="p">{</span> <span class="n">buildView</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">var</span> <span class="nv">look</span><span class="p">:</span> <span class="kt">Vec3</span> <span class="p">{</span> <span class="k">didSet</span> <span class="p">{</span> <span class="n">buildView</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">var</span> <span class="nv">up</span><span class="p">:</span> <span class="kt">Vec3</span> <span class="p">{</span> <span class="k">didSet</span> <span class="p">{</span> <span class="n">buildView</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">var</span> <span class="nv">fovYDegrees</span><span class="p">:</span> <span class="kt">Float</span> <span class="p">{</span> <span class="k">didSet</span> <span class="p">{</span> <span class="n">buildProjection</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">var</span> <span class="nv">aspectRatio</span><span class="p">:</span> <span class="kt">Float</span> <span class="p">{</span> <span class="k">didSet</span> <span class="p">{</span> <span class="n">buildProjection</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">var</span> <span class="nv">zNear</span><span class="p">:</span> <span class="kt">Float</span> <span class="p">{</span> <span class="k">didSet</span> <span class="p">{</span> <span class="n">buildProjection</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">var</span> <span class="nv">zFar</span><span class="p">:</span> <span class="kt">Float</span> <span class="p">{</span> <span class="k">didSet</span> <span class="p">{</span> <span class="n">buildProjection</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}</span>

  <span class="kd">private</span> <span class="k">var</span> <span class="nv">buildProjection</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">buildView</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">_projectionMatrix</span> <span class="o">=</span> <span class="kt">Mat4</span><span class="o">.</span><span class="n">identity</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">_viewMatrix</span> <span class="o">=</span> <span class="kt">Mat4</span><span class="o">.</span><span class="n">identity</span>

  <span class="k">var</span> <span class="nv">projectionMatrix</span><span class="p">:</span> <span class="kt">Mat4</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">buildProjection</span> <span class="p">{</span>
        <span class="n">buildProjection</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="n">_projectionMatrix</span> <span class="o">=</span> <span class="kt">Math</span><span class="o">.</span><span class="nf">makePerspective</span><span class="p">(</span>
          <span class="nv">fovyDegrees</span><span class="p">:</span> <span class="n">fovYDegrees</span><span class="p">,</span>
          <span class="nv">aspectRatio</span><span class="p">:</span> <span class="n">aspectRatio</span><span class="p">,</span>
          <span class="nv">nearZ</span><span class="p">:</span> <span class="n">zNear</span><span class="p">,</span>
          <span class="nv">farZ</span><span class="p">:</span> <span class="n">zFar</span>
        <span class="p">)</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">_projectionMatrix</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">viewMatrix</span><span class="p">:</span> <span class="kt">Mat4</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">buildView</span> <span class="p">{</span>
        <span class="n">buildView</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="n">_viewMatrix</span> <span class="o">=</span> <span class="kt">Math</span><span class="o">.</span><span class="nf">makeLook</span><span class="p">(</span><span class="nv">eye</span><span class="p">:</span> <span class="n">origin</span><span class="p">,</span> <span class="nv">look</span><span class="p">:</span> <span class="n">look</span><span class="p">,</span> <span class="nv">up</span><span class="p">:</span> <span class="n">up</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">_viewMatrix</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nf">init</span><span class="p">(</span>
    <span class="nv">origin</span><span class="p">:</span> <span class="kt">Vec3</span><span class="p">,</span>
    <span class="nv">look</span><span class="p">:</span> <span class="kt">Vec3</span><span class="p">,</span>
    <span class="nv">up</span><span class="p">:</span> <span class="kt">Vec3</span><span class="p">,</span>
    <span class="nv">fovYDegrees</span><span class="p">:</span> <span class="kt">Float</span><span class="p">,</span>
    <span class="nv">aspectRatio</span><span class="p">:</span> <span class="kt">Float</span><span class="p">,</span>
    <span class="nv">zNear</span><span class="p">:</span> <span class="kt">Float</span><span class="p">,</span>
    <span class="nv">zFar</span><span class="p">:</span> <span class="kt">Float</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
    <span class="k">self</span><span class="o">.</span><span class="n">look</span> <span class="o">=</span> <span class="n">look</span>
    <span class="k">self</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">up</span>
    <span class="k">self</span><span class="o">.</span><span class="n">fovYDegrees</span> <span class="o">=</span> <span class="n">fovYDegrees</span>
    <span class="k">self</span><span class="o">.</span><span class="n">aspectRatio</span> <span class="o">=</span> <span class="n">aspectRatio</span>
    <span class="k">self</span><span class="o">.</span><span class="n">zNear</span> <span class="o">=</span> <span class="n">zNear</span>
    <span class="k">self</span><span class="o">.</span><span class="n">zFar</span> <span class="o">=</span> <span class="n">zFar</span>
  <span class="p">}</span>

<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mesh">Mesh</h3>
<div class="paragraph">
<p>A mesh contains all of the 3D vertex data for the model and also the material that should be used to render the model (solid color, texture etc).</p>
</div>
<div class="paragraph">
<p>The mesh is then responsible for setting the vertex buffer in the rendering pipeline and actually submitting the final draw command.</p>
</div>
<div class="listingblock">
<div class="title">Mesh.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">MetalKit</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">Mesh</span> <span class="p">{</span>

  <span class="kd">public</span> <span class="kd">struct</span> <span class="kt">VertexBuffer</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">buffer</span><span class="p">:</span> <span class="kt">MTLBuffer</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">bufferIndex</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">primitiveType</span><span class="p">:</span> <span class="kt">MTLPrimitiveType</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">vertexCount</span><span class="p">:</span> <span class="kt">Int</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">buffer</span><span class="p">:</span> <span class="kt">MTLBuffer</span><span class="p">,</span> <span class="nv">bufferIndex</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">primitiveType</span><span class="p">:</span> <span class="kt">MTLPrimitiveType</span><span class="p">,</span> <span class="nv">vertexCount</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">buffer</span>
      <span class="k">self</span><span class="o">.</span><span class="n">bufferIndex</span> <span class="o">=</span> <span class="n">bufferIndex</span>
      <span class="k">self</span><span class="o">.</span><span class="n">primitiveType</span> <span class="o">=</span> <span class="n">primitiveType</span>
      <span class="k">self</span><span class="o">.</span><span class="n">vertexCount</span> <span class="o">=</span> <span class="n">vertexCount</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="k">let</span> <span class="nv">vertexBuffer</span><span class="p">:</span> <span class="kt">VertexBuffer</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">material</span><span class="p">:</span> <span class="kt">Material</span><span class="p">?</span>

  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">vertexBuffer</span><span class="p">:</span> <span class="kt">VertexBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">vertexBuffer</span> <span class="o">=</span> <span class="n">vertexBuffer</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">render</span><span class="p">(</span><span class="nv">encoder</span><span class="p">:</span> <span class="kt">MTLRenderCommandEncoder</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">encoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="n">vertexBuffer</span><span class="o">.</span><span class="n">bufferIndex</span><span class="p">)</span>
    <span class="n">encoder</span><span class="o">.</span><span class="nf">drawPrimitives</span><span class="p">(</span>
      <span class="nv">type</span><span class="p">:</span> <span class="n">vertexBuffer</span><span class="o">.</span><span class="n">primitiveType</span><span class="p">,</span>
      <span class="nv">vertexStart</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nv">vertexCount</span><span class="p">:</span> <span class="n">vertexBuffer</span><span class="o">.</span><span class="n">vertexCount</span><span class="p">,</span>
      <span class="nv">instanceCount</span><span class="p">:</span> <span class="mi">1</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_node">Node</h3>
<div class="paragraph">
<p>The Node class represents a way to take 3D local data and transform them in to a point in the world.
The node has a position, orientation and scale property that you can set to move the content in the world.
It also has an optional mesh property, the mesh is used to describe the 3D data associated with the node.
Nodes can contain other child nodes, in this way we can create our scene hierarchy of transforms.</p>
</div>
<div class="listingblock">
<div class="title">Node.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">Node</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">position</span> <span class="o">=</span> <span class="kt">Vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">orientation</span> <span class="o">=</span> <span class="kt">Quaternion</span><span class="o">.</span><span class="n">identity</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">scale</span> <span class="o">=</span> <span class="kt">Vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

  <span class="cm">/**
   The mesh associated with the node. Note that this is optional, a mesh can just be a container
   for other child nodes and not have any renderable information associated with it.
   */</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">mesh</span><span class="p">:</span> <span class="kt">Mesh</span><span class="p">?</span>

  <span class="cm">/**
   The update function can be used to modify the node parameters every frame. If this closure is
   present it will be called once before the render call, every frame. You could use this to rotate
   the node etc.
   */</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">update</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">time</span><span class="p">:</span> <span class="kt">Time</span><span class="p">,</span> <span class="n">_</span> <span class="nv">node</span><span class="p">:</span> <span class="kt">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span>

  <span class="cm">/**
   Returns a matrix that is the combination of the position, orientation and scale properties.
   These are applied in scale -&gt; rotate -&gt; translate order.
   */</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">transform</span><span class="p">:</span> <span class="kt">Mat4</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">translate</span> <span class="o">=</span> <span class="kt">Mat4</span><span class="o">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">s</span> <span class="o">=</span> <span class="kt">Mat4</span><span class="o">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">scale</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">scale</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">scale</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">translate</span> <span class="o">*</span> <span class="n">orientation</span><span class="o">.</span><span class="nf">toMat</span><span class="p">()</span> <span class="o">*</span> <span class="n">s</span>
  <span class="p">}</span>

  <span class="kd">private</span> <span class="k">var</span> <span class="nv">children</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Node</span><span class="p">]()</span>

  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">mesh</span><span class="p">:</span> <span class="kt">Mesh</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As well as these simple properties, the other main job of the Node is to setup some of the rendering state.
If the node has a mesh, we will take the material associated with the mesh and setup the fragment shader.
This is also where we pass in the current model matrix to the vertex shader so that it can perform the local &#8594; world transform.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">func</span> <span class="nf">render</span><span class="p">(</span>
  <span class="nv">time</span><span class="p">:</span> <span class="kt">Time</span><span class="p">,</span>
  <span class="nv">camera</span><span class="p">:</span> <span class="kt">PerspectiveCamera</span><span class="p">,</span>
  <span class="nv">renderer</span><span class="p">:</span> <span class="kt">Renderer</span><span class="p">,</span>
  <span class="nv">encoder</span><span class="p">:</span> <span class="kt">MTLRenderCommandEncoder</span><span class="p">,</span>
  <span class="nv">parentTransform</span><span class="p">:</span> <span class="kt">Mat4</span>
<span class="p">)</span> <span class="p">{</span>

  <span class="k">let</span> <span class="nv">worldTransform</span> <span class="o">=</span> <span class="n">parentTransform</span> <span class="o">*</span> <span class="n">transform</span>

  <span class="c1">// If there is no mesh then this is simply a passthrough node that contains</span>
  <span class="c1">// other nodes</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="k">let</span> <span class="nv">material</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">material</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">constants</span> <span class="o">=</span> <span class="kt">ModelConstants</span><span class="p">(</span><span class="nv">modelMatrix</span><span class="p">:</span> <span class="n">worldTransform</span><span class="p">)</span>
    <span class="n">encoder</span><span class="o">.</span><span class="nf">setVertexBytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">constants</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">ModelConstants</span><span class="o">&gt;.</span><span class="n">size</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nv">texture</span> <span class="o">=</span> <span class="n">material</span><span class="o">.</span><span class="n">texture</span> <span class="p">{</span>
      <span class="n">encoder</span><span class="o">.</span><span class="nf">setFragmentTexture</span><span class="p">(</span><span class="n">texture</span><span class="o">.</span><span class="n">mtlTexture</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">encoder</span><span class="o">.</span><span class="nf">setFragmentSamplerState</span><span class="p">(</span><span class="n">texture</span><span class="o">.</span><span class="n">samplerState</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">encoder</span><span class="o">.</span><span class="nf">setRenderPipelineState</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">renderPipelineState</span><span class="p">)</span>
    <span class="n">mesh</span><span class="o">.</span><span class="nf">render</span><span class="p">(</span><span class="nv">encoder</span><span class="p">:</span> <span class="n">encoder</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">node</span> <span class="k">in</span> <span class="n">children</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">.</span><span class="nf">render</span><span class="p">(</span>
      <span class="nv">time</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
      <span class="nv">camera</span><span class="p">:</span> <span class="n">camera</span><span class="p">,</span>
      <span class="nv">renderer</span><span class="p">:</span> <span class="n">renderer</span><span class="p">,</span>
      <span class="nv">encoder</span><span class="p">:</span> <span class="n">encoder</span><span class="p">,</span>
      <span class="nv">parentTransform</span><span class="p">:</span> <span class="n">worldTransform</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_material">Material</h3>
<div class="paragraph">
<p>When you want to render your 3D content, as well as the topology of the model such as the points in 3D space and the relationships between those points, how they compose to make primitives such as triangles or lines, we need to also be able to have some way of changing their visual appearance.
This is where shaders come in.</p>
</div>
<div class="paragraph">
<p>The Material class encapsulates which Vertex + Fragment shader should be used to draw the content, as well as specifying how the data should be stored in the vertex buffer in order for it to be accessed in the shaders.
Going back to the Metal types, MTLRenderPipelineState is the object that stores the compiled vertex + fragment shaders, so inside our Material class we are just going to setup one of these objects.</p>
</div>
<div class="paragraph">
<p>Obviously the shaders require that the vertex buffers have the correct data that the shader needs and also that the caller has put the data in the correct order inside the buffer. If you have put color information where the shader was expecting x,y,z values for a 3D point, you&#8217;re going to have a bad time.</p>
</div>
<div class="listingblock">
<div class="title">Material.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Metal</span>

<span class="kd">class</span> <span class="kt">Material</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">renderPipelineState</span><span class="p">:</span> <span class="kt">MTLRenderPipelineState</span>

  <span class="nf">init</span><span class="p">?(</span>
    <span class="nv">renderer</span><span class="p">:</span> <span class="kt">Renderer</span><span class="p">,</span>
    <span class="nv">vertexName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
    <span class="nv">fragmentName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
    <span class="nv">vertexDescriptor</span><span class="p">:</span> <span class="kt">MTLVertexDescriptor</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">descriptor</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="nf">defaultPipelineDescriptor</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">fragmentProgram</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">library</span><span class="o">.</span><span class="nf">makeFunction</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">vertexName</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">vertexProgram</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">library</span><span class="o">.</span><span class="nf">makeFunction</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">fragmentName</span><span class="p">)</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">vertexFunction</span> <span class="o">=</span> <span class="n">vertexProgram</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">fragmentFunction</span> <span class="o">=</span> <span class="n">fragmentProgram</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">vertexDescriptor</span> <span class="o">=</span> <span class="n">vertexDescriptor</span>

    <span class="k">guard</span> <span class="k">let</span> <span class="nv">state</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">renderer</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="nf">makeRenderPipelineState</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">descriptor</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="n">renderPipelineState</span> <span class="o">=</span> <span class="n">state</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have this base class, we can create any number of Materials that can be used to render models differently.
In Toy3D there is function to create a BasicMaterial which supports solid colors and texturing of models.</p>
</div>
<div class="listingblock">
<div class="title">Material.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">extension</span> <span class="kt">Material</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">createBasic</span><span class="p">(</span><span class="nv">renderer</span><span class="p">:</span> <span class="kt">Renderer</span><span class="p">,</span> <span class="nv">texture</span><span class="p">:</span> <span class="kt">Texture</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Material</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">descriptor</span> <span class="o">=</span> <span class="kt">MTLVertexDescriptor</span><span class="p">()</span>

    <span class="c1">// Some vertex buffers are reserved by the render, this gives us the first</span>
    <span class="c1">// free vertex buffer that we can use.</span>
    <span class="k">let</span> <span class="nv">bufferIndex</span> <span class="o">=</span> <span class="kt">Renderer</span><span class="o">.</span><span class="n">firstFreeVertexBufferIndex</span>

    <span class="c1">// position x,y,z</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="o">.</span><span class="n">float3</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bufferIndex</span> <span class="o">=</span> <span class="n">bufferIndex</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">// normal x,y,z</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="o">.</span><span class="n">float3</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bufferIndex</span> <span class="o">=</span> <span class="n">bufferIndex</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;.</span><span class="n">stride</span> <span class="o">*</span> <span class="mi">3</span>

    <span class="c1">// color r,g,b,a</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="o">.</span><span class="n">float4</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bufferIndex</span> <span class="o">=</span> <span class="n">bufferIndex</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;.</span><span class="n">stride</span> <span class="o">*</span> <span class="mi">6</span>

    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="o">.</span><span class="n">float2</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">bufferIndex</span> <span class="o">=</span> <span class="n">bufferIndex</span>
    <span class="n">descriptor</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;.</span><span class="n">stride</span> <span class="o">*</span> <span class="mi">10</span>

    <span class="n">descriptor</span><span class="o">.</span><span class="n">layouts</span><span class="p">[</span><span class="n">bufferIndex</span><span class="p">]</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Float</span><span class="o">&gt;.</span><span class="n">stride</span> <span class="o">*</span> <span class="mi">12</span>

    <span class="k">return</span> <span class="kt">Material</span><span class="p">(</span>
      <span class="nv">renderer</span><span class="p">:</span> <span class="n">renderer</span><span class="p">,</span>
      <span class="nv">vertexName</span><span class="p">:</span> <span class="s">"basic_vertex"</span><span class="p">,</span>
      <span class="nv">fragmentName</span><span class="p">:</span> <span class="n">texture</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">?</span> <span class="s">"texture_fragment"</span> <span class="p">:</span> <span class="s">"color_fragment"</span><span class="p">,</span>
      <span class="nv">vertexDescriptor</span><span class="p">:</span> <span class="n">descriptor</span><span class="p">,</span>
      <span class="nv">texture</span><span class="p">:</span> <span class="n">texture</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here you see we have specified the vertex and fragment shader we want to use in our .metal file.
We also have specified how the data should be laid out in the vertex buffer when using these shaders.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Notice how we are binding the data to bufferIndex Renderer.firstFreeVertexBufferIndex.
Buffers 0 and 1 are bound by data in the engine, so buffer Renderer.firstFreeVertexBufferIndex and up are the free buffers you should use for your own data.
If you try to bind to buffers below that things will break.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_texture">Texture</h3>
<div class="paragraph">
<p>The texture class will represent one texture in the system.
It will store a reference to an MTLTexture instance and also to a MTLSamplerState object that is used to access the texture.
We also add a simple helper method to load a texture.</p>
</div>
<div class="listingblock">
<div class="title">Texture.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">MetalKit</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">Texture</span> <span class="p">{</span>

  <span class="k">let</span> <span class="nv">mtlTexture</span><span class="p">:</span> <span class="kt">MTLTexture</span>
  <span class="k">let</span> <span class="nv">samplerState</span><span class="p">:</span> <span class="kt">MTLSamplerState</span>

  <span class="nf">init</span><span class="p">(</span><span class="nv">mtlTexture</span><span class="p">:</span> <span class="kt">MTLTexture</span><span class="p">,</span> <span class="nv">samplerState</span><span class="p">:</span> <span class="kt">MTLSamplerState</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">mtlTexture</span> <span class="o">=</span> <span class="n">mtlTexture</span>
    <span class="k">self</span><span class="o">.</span><span class="n">samplerState</span> <span class="o">=</span> <span class="n">samplerState</span>
  <span class="p">}</span>

  <span class="c1">/// Loads a texture from the main bundle with the given name</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">loadMetalTexture</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="kt">MTLDevice</span><span class="p">,</span> <span class="nv">named</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">MTLTexture</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">texLoader</span> <span class="o">=</span> <span class="kt">MTKTextureLoader</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">try</span><span class="p">?</span> <span class="n">texLoader</span><span class="o">.</span><span class="nf">newTexture</span><span class="p">(</span>
      <span class="nv">name</span><span class="p">:</span> <span class="n">named</span><span class="p">,</span>
      <span class="nv">scaleFactor</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
      <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
      <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="nv">generateMipmaps</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Texture creation example</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">guard</span> <span class="k">let</span> <span class="nv">mtlTexture</span> <span class="o">=</span> <span class="kt">Texture</span><span class="o">.</span><span class="nf">loadMetalTexture</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="n">renderer</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="nv">named</span><span class="p">:</span> <span class="s">"myImage"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">descriptor</span> <span class="o">=</span> <span class="kt">MTLSamplerDescriptor</span><span class="p">()</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">normalizedCoordinates</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">minFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">magFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
<span class="n">descriptor</span><span class="o">.</span><span class="n">mipFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">sampler</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeSamplerState</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">descriptor</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">texture</span> <span class="o">=</span> <span class="kt">Texture</span><span class="p">(</span><span class="nv">mtlTexture</span><span class="p">:</span> <span class="n">mtlTexture</span><span class="p">,</span> <span class="nv">samplerState</span><span class="p">:</span> <span class="n">sampler</span><span class="p">)</span>

<span class="c1">// Use the texture in our app</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_basicvertex">BasicVertex</h3>
<div class="paragraph">
<p>We will create a simple struct to help us define some 3D data that will let use provide position, normal, color and texture coordinates for the vertices of a model.</p>
</div>
<div class="listingblock">
<div class="title">BasicVertex.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Metal</span>

<span class="cm">/**
 BasicVertex represents a common set of values that you might want to associate with a vertex.

 This one supports position, color, normal and texture coordinates.
 */</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">BasicVertex</span> <span class="p">{</span>

  <span class="c1">// position</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nv">z</span> <span class="p">:</span> <span class="kt">Float</span>

  <span class="c1">// normal</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="nv">nz</span><span class="p">:</span> <span class="kt">Float</span>

  <span class="c1">// color</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Float</span>

  <span class="c1">// texCoords</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">u</span><span class="p">,</span> <span class="nv">v</span><span class="p">:</span> <span class="kt">Float</span>

  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">pos</span><span class="p">:</span> <span class="kt">Vec3</span><span class="p">,</span> <span class="nv">normal</span><span class="p">:</span> <span class="kt">Vec3</span><span class="p">,</span> <span class="nv">color</span><span class="p">:</span> <span class="kt">Vec4</span><span class="p">,</span> <span class="nv">tex</span><span class="p">:</span> <span class="kt">Vec2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">x</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">y</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">z</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">x</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">y</span>
    <span class="n">nz</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">z</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">x</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">y</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">z</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">w</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">tex</span><span class="o">.</span><span class="n">x</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">tex</span><span class="o">.</span><span class="n">y</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">floatBuffer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Float</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="c1">/// Given an array of vertices, returns an MTLBuffer containing the vertex data</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">toBuffer</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="kt">MTLDevice</span><span class="p">,</span> <span class="nv">vertices</span><span class="p">:</span> <span class="p">[</span><span class="kt">BasicVertex</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">MTLBuffer</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">data</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Float</span><span class="p">]()</span>
    <span class="n">vertices</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="p">(</span><span class="n">vertex</span><span class="p">)</span> <span class="k">in</span>
      <span class="n">data</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">contentsOf</span><span class="p">:</span> <span class="n">vertex</span><span class="o">.</span><span class="nf">floatBuffer</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">size</span> <span class="o">=</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">BasicVertex</span><span class="o">&gt;.</span><span class="n">stride</span> <span class="o">*</span> <span class="n">vertices</span><span class="o">.</span><span class="n">count</span>
    <span class="k">return</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeBuffer</span><span class="p">(</span><span class="nv">bytes</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[])</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_time">Time</h3>
<div class="paragraph">
<p>The Time struct contains two values, one is a totalTime property that is a monotonic increasing value. The other is updateTime which is the time since the last update call. This is useful for animations where you don&#8217;t want to just add a fixed amount every frame to an animation e.g. rotationX += 10, since if the frames don&#8217;t render at an even rate things will jump, however you can just use the delta to compute how much the value should change based on some fixed amount per unit time.</p>
</div>
<div class="listingblock">
<div class="title">Time.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">Time</span> <span class="p">{</span>

  <span class="c1">/// The total time of the app. This is just a number that is always</span>
  <span class="c1">/// increasing, it might not start at 0, just use it for relative calculations</span>
  <span class="k">let</span> <span class="nv">totalTime</span><span class="p">:</span> <span class="kt">TimeInterval</span>

  <span class="c1">/// The time since the last update call</span>
  <span class="k">let</span> <span class="nv">updateTime</span><span class="p">:</span> <span class="kt">TimeInterval</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buffers">Buffers</h3>
<div class="paragraph">
<p>The way we transfer data to and from the CPU and GPU is through buffers.
Buffers are just blocks of memory.
As we have seen we can create a new buffer to store our vertex data using device.createBuffer()</p>
</div>
<div class="paragraph">
<p>However, we don&#8217;t just need to pass vertex data to the shaders, we also have other pieces of information, most commonly the projectionMatrix, viewMatrix and modelMatrix that are used to transform the local 3D points in the model to world values that can then be projected in to 2D. The way we pass this information in Metal is the sames as the vertices, we just use a buffer.</p>
</div>
<div class="paragraph">
<p>The view and projection matrix are constant across all models in the frame, we can create a struct to set them in the Swift code:</p>
</div>
<div class="listingblock">
<div class="title">Uniforms.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">Uniforms</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">viewProjection</span><span class="p">:</span> <span class="kt">Mat4</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can allocate a buffer that will hold the contents of this struct which can be accessed in the vertex shader.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="c1">// Create the buffer</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">uniformBuffer</span><span class="p">:</span> <span class="kt">MTLBuffer</span><span class="p">?</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeBuffer</span><span class="p">(</span><span class="nv">length</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Uniforms</span><span class="o">&gt;.</span><span class="n">size</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[])</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Populate it with some values</span>
<span class="k">let</span> <span class="nv">uniformContents</span> <span class="o">=</span> <span class="n">uniformBuffer</span><span class="o">.</span><span class="nf">contents</span><span class="p">()</span><span class="o">.</span><span class="nf">bindMemory</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">Uniforms</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">uniformContents</span><span class="o">.</span><span class="n">pointee</span><span class="o">.</span><span class="n">viewProjection</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">projectionMatrix</span> <span class="o">*</span> <span class="n">scene</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">viewMatrix</span>

<span class="c1">// Bind the buffer to buffer 0</span>
<span class="n">encoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">uniformBuffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now on the vertex shader side we access the uniforms by binding to the buffer 0 slot</p>
</div>
<div class="listingblock">
<div class="title">Shaders.metal</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="msl">vertex VertexOut basic_vertex(
  const VertexIn vIn [[ stage_in ]],
  const device Uniforms&amp; uniforms [[ buffer(0) ]]) {

  // ...
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_synchronizing_memory_access">Synchronizing Memory Access</h4>
<div class="paragraph">
<p>The above is fine, but there is a subtle problem.
If we create a single buffer to be used to store our per frame values and use that across multiple frames, the CPU and GPU may actually be working on different frames at the same time.
For example, the CPU sets up frame 0 and submits it, then sets up frame 1 and submits it and so on.
The GPU receives these requests and processes them, but it can fall behind the CPU.</p>
</div>
<div class="paragraph">
<p>Hence it could actually be the case that we populate the uniform buffer with data for frame 0, submit it, then immediately update the uniform buffer with frame 1 values while the GPU is still trying to process frame 0 data.
This can happen because the buffer memory is shared between the CPU + GPU.</p>
</div>
<div class="paragraph">
<p>Because of this we need to make sure that we have separate buffers for each frame that can be written and read from without affecting other frames.</p>
</div>
<div class="paragraph">
<p>Apple has a great write up on this <a href="https://developer.apple.com/documentation/metal/synchronization/synchronizing_cpu_and_gpu_work">here</a>.
In our engine, we create a buffer pool, each frame can grab a new buffer to store the uniform data, then once it is processed we can return it to the pool.
We know when the GPU has completed processing all the commands by using the completed callback on the MTLCommandBuffer instance.</p>
</div>
<div class="paragraph">
<p>There is a simple class called BufferManager, when you initialize it you say how many buffers you need and how to initiaize those buffers:</p>
</div>
<div class="listingblock">
<div class="title">Renderer.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">uniformBuffers</span> <span class="o">=</span> <span class="kt">BufferManager</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="n">device</span><span class="p">,</span> <span class="nv">inflightCount</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nv">createBuffer</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">return</span> <span class="n">device</span><span class="o">.</span><span class="nf">makeBuffer</span><span class="p">(</span><span class="nv">length</span><span class="p">:</span> <span class="kt">MemoryLayout</span><span class="o">&lt;</span><span class="kt">Uniforms</span><span class="o">&gt;.</span><span class="n">size</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[])</span>
<span class="p">})</span>
<span class="n">uniformBuffers</span><span class="o">.</span><span class="nf">createBuffers</span><span class="p">()</span>

<span class="c1">// Inside the per frame render method</span>

<span class="c1">// Get the buffer and update values</span>
<span class="k">let</span> <span class="nv">uniformBuffer</span> <span class="o">=</span> <span class="n">uniformBuffers</span><span class="o">.</span><span class="nf">nextSync</span><span class="p">()</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">commandBuffer</span> <span class="o">=</span> <span class="n">commandQueue</span><span class="o">.</span><span class="nf">makeCommandBuffer</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Submit draw commands</span>

<span class="c1">// Wait the the commands to complete</span>
<span class="n">commandBuffer</span><span class="o">.</span><span class="n">addCompletedHandler</span> <span class="p">{</span> <span class="p">(</span><span class="kt">MTLCommandBuffer</span><span class="p">)</span> <span class="k">in</span>
  <span class="n">uniformBuffers</span><span class="o">.</span><span class="nf">release</span><span class="p">()</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The BufferManager class uses the DispatchSemaphore class to manage access to the resources.</p>
</div>
<div class="listingblock">
<div class="title">BufferManager.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Metal</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">BufferManager</span> <span class="p">{</span>

  <span class="kd">private</span> <span class="k">let</span> <span class="nv">device</span><span class="p">:</span> <span class="kt">MTLDevice</span>
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">inflightCount</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">bufferIndex</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">createBuffer</span><span class="p">:</span> <span class="p">(</span><span class="kt">MTLDevice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">MTLBuffer</span><span class="p">?</span>
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">semaphore</span><span class="p">:</span> <span class="kt">DispatchSemaphore</span>
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">buffers</span><span class="p">:</span> <span class="p">[</span><span class="kt">MTLBuffer</span><span class="p">]</span>

  <span class="cm">/**
   - parameters:
     - device: The metal device
     - inflightCount: The number of buffers to manage
     - createBuffer: a closure that will ne called inflightCount times to create the buffers
   */</span>
  <span class="nf">init</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="kt">MTLDevice</span><span class="p">,</span> <span class="nv">inflightCount</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">createBuffer</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">MTLDevice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">MTLBuffer</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
    <span class="k">self</span><span class="o">.</span><span class="n">inflightCount</span> <span class="o">=</span> <span class="n">inflightCount</span>
    <span class="k">self</span><span class="o">.</span><span class="n">createBuffer</span> <span class="o">=</span> <span class="n">createBuffer</span>
    <span class="n">semaphore</span> <span class="o">=</span> <span class="kt">DispatchSemaphore</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">inflightCount</span><span class="p">)</span>
    <span class="n">buffers</span> <span class="o">=</span> <span class="p">[</span><span class="kt">MTLBuffer</span><span class="p">]()</span>
  <span class="p">}</span>

  <span class="c1">/// You must call this before calling nextSync()</span>
  <span class="kd">func</span> <span class="nf">createBuffers</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">inflightCount</span> <span class="p">{</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nv">buffer</span> <span class="o">=</span> <span class="nf">createBuffer</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffers</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Failed to create buffer"</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// Returns the next free buffer. If a buffer is not available this will block the caller</span>
  <span class="kd">func</span> <span class="nf">nextSync</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">MTLBuffer</span> <span class="p">{</span>
    <span class="n">semaphore</span><span class="o">.</span><span class="nf">wait</span><span class="p">()</span>

    <span class="k">let</span> <span class="nv">buffer</span> <span class="o">=</span> <span class="n">buffers</span><span class="p">[</span><span class="n">bufferIndex</span><span class="p">]</span>
    <span class="n">bufferIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">bufferIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">inflightCount</span>
    <span class="k">return</span> <span class="n">buffer</span>
  <span class="p">}</span>

  <span class="cm">/**
   Indicates a buffer has been released.

   - note: There is an implicit assumption that buffers are released in the same order
           that they were acquired in.
   */</span>
  <span class="kd">func</span> <span class="nf">release</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">semaphore</span><span class="o">.</span><span class="nf">signal</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setvertexbytes">setVertexBytes</h4>
<div class="paragraph">
<p>You can also use the MTLRenderCommandEncoder <a href="https://developer.apple.com/documentation/metal/mtlrendercommandencoder/1515846-setvertexbytes">setVertexBytes</a> method to get a temporary buffer from a pool of buffers managed by the device.
You can use these buffers for small blocks of data &lt;4KB</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You could also put the per frame values like view, model and projection matrix in the same buffer as your vertex data if you want, it is entirely up to you. You could write those at the beginning of the buffer and then offset the vertex data after them. You can then bind your Vertex shader structs to the same buffer at different offset. There are many ways of passing the data through, some might be more efficient for larger data.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_model_io">Model I/O</h3>
<div class="paragraph">
<p>As well as defining our own Mesh vertex data, we also want to be able to import models from 3rd parties.
There are many 3D model formats used in the real world, .obj, .ply, .usd and so on.
<a href="https://developer.apple.com/documentation/modelio">Model I/O</a> is a framework from Apple that makes it very easy to import and export data from multiple formats. We will add support for Model I/O to our simple engine.</p>
</div>
<div class="paragraph">
<p>Model I/O has a class called <a href="https://developer.apple.com/documentation/modelio/mdlasset">MDLAsset</a>.
This class is used to load the external data into Model I/O data structures.
Once we have the MDLAsset instance, we can then use MetalKit to create a MetalKit mesh <a href="https://developer.apple.com/documentation/metalkit/mtkmesh">MTKMesh</a>.
A MTKMesh can then be used to get access to MTLBuffer instances that we can use to render the model.</p>
</div>
<div class="paragraph">
<p>In our Mesh class we will support taking in a MTKMesh instance in the initializer:</p>
</div>
<div class="listingblock">
<div class="title">Mesh.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">Mesh</span> <span class="p">{</span>

  <span class="kd">public</span> <span class="k">var</span> <span class="nv">mtkMesh</span><span class="p">:</span> <span class="kt">MTKMesh</span><span class="p">?</span>

  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">mtkMesh</span><span class="p">:</span> <span class="kt">MTKMesh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">mtkMesh</span> <span class="o">=</span> <span class="n">mtkMesh</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The MTKMesh contains a vertex buffer that has all the 3D vertex data, then also a collection of SubMeshes.</p>
</div>
<div class="listingblock">
<div class="title">Mesh.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">func</span> <span class="nf">render</span><span class="p">(</span><span class="nv">encoder</span><span class="p">:</span> <span class="kt">MTLRenderCommandEncoder</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nv">mesh</span> <span class="o">=</span> <span class="n">mtkMesh</span> <span class="p">{</span>
      <span class="n">encoder</span><span class="o">.</span><span class="nf">setVertexBuffer</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertexBuffers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">index</span><span class="p">:</span> <span class="kt">Renderer</span><span class="o">.</span><span class="n">firstFreeVertexBufferIndex</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">submesh</span> <span class="k">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submeshes</span> <span class="p">{</span>
        <span class="n">encoder</span><span class="o">.</span><span class="nf">drawIndexedPrimitives</span><span class="p">(</span>
          <span class="nv">type</span><span class="p">:</span> <span class="o">.</span><span class="n">triangle</span><span class="p">,</span>
          <span class="nv">indexCount</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">indexCount</span><span class="p">,</span>
          <span class="nv">indexType</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">indexType</span><span class="p">,</span>
          <span class="nv">indexBuffer</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">indexBuffer</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span>
          <span class="nv">indexBufferOffset</span><span class="p">:</span> <span class="n">submesh</span><span class="o">.</span><span class="n">indexBuffer</span><span class="o">.</span><span class="n">offset</span>
        <span class="p">)</span>
      <span class="p">}</span>
      <span class="k">return</span>
    <span class="p">}</span>

    <span class="c1">// Otherwise just use our own MTL buffer</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For an example of how to load an MDLAsset see the Examples.swift file in the Sample project: <a href="https://github.com/markdaws/metal-example/blob/master/metal-example/Examples.swift" class="bare">https://github.com/markdaws/metal-example/blob/master/metal-example/Examples.swift</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">Examples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now we have all the pieces of our 3D engine in place we can make some examples.</p>
</div>
<div class="paragraph">
<p>The basic flow will be:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create the Renderer passing in an instance of MTKView</p>
</li>
<li>
<p>Create a Mesh that has all of the 3D vertex information</p>
</li>
<li>
<p>Create a Material to use to describe how the Mesh should look, solid color, textured etc.</p>
</li>
<li>
<p>Create a Node to hold the Mesh instance. Set the transform on the Node to move the Mesh in the world</p>
</li>
<li>
<p>Add the Node to the Scene</p>
</li>
<li>
<p>Profit!</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/solidcube.jpg" alt="solidcube">
</div>
<div class="title">A solid color cube</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/texturedcube.jpg" alt="texturedcube">
</div>
<div class="title">A cube with textured faces</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/10000cubes.jpg" alt="10000cubes">
</div>
<div class="title">10,000 animated cubes</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/bunny.jpg" alt="bunny">
</div>
<div class="title">Textured Stanford bunny (<a href="https://casual-effects.com/data/">Source</a>)</div>
</div>
<div class="paragraph">
<p>The code to create the cube sample is pretty simple:</p>
</div>
<div class="listingblock">
<div class="title">Examples.swift</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">func</span> <span class="nf">createSingleCube</span><span class="p">(</span><span class="nv">renderer</span><span class="p">:</span> <span class="kt">Renderer</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">guard</span> <span class="k">let</span> <span class="nv">metalTexture</span> <span class="o">=</span> <span class="kt">Texture</span><span class="o">.</span><span class="nf">loadMetalTexture</span><span class="p">(</span><span class="nv">device</span><span class="p">:</span> <span class="n">renderer</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="nv">named</span><span class="p">:</span> <span class="s">"bricks"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="nv">samplerDescriptor</span> <span class="o">=</span> <span class="kt">MTLSamplerDescriptor</span><span class="p">()</span>
  <span class="n">samplerDescriptor</span><span class="o">.</span><span class="n">normalizedCoordinates</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="n">samplerDescriptor</span><span class="o">.</span><span class="n">minFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
  <span class="n">samplerDescriptor</span><span class="o">.</span><span class="n">magFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
  <span class="n">samplerDescriptor</span><span class="o">.</span><span class="n">mipFilter</span> <span class="o">=</span> <span class="o">.</span><span class="n">linear</span>
  <span class="k">guard</span> <span class="k">let</span> <span class="nv">sampler</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="nf">makeSamplerState</span><span class="p">(</span><span class="nv">descriptor</span><span class="p">:</span> <span class="n">samplerDescriptor</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="nv">texture</span> <span class="o">=</span> <span class="kt">Texture</span><span class="p">(</span><span class="nv">mtlTexture</span><span class="p">:</span> <span class="n">metalTexture</span><span class="p">,</span> <span class="nv">samplerState</span><span class="p">:</span> <span class="n">sampler</span><span class="p">)</span>
  <span class="k">let</span> <span class="nv">material</span> <span class="o">=</span> <span class="kt">Material</span><span class="o">.</span><span class="nf">createBasic</span><span class="p">(</span><span class="nv">renderer</span><span class="p">:</span> <span class="n">renderer</span><span class="p">,</span> <span class="nv">texture</span><span class="p">:</span> <span class="n">texture</span><span class="p">)</span>

  <span class="c1">// Define the 3D vertices and colors for the vertices</span>
  <span class="k">let</span> <span class="nv">dimension</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">3.0</span>
  <span class="k">guard</span> <span class="k">let</span> <span class="nv">cubeMesh</span> <span class="o">=</span> <span class="kt">Primitives</span><span class="o">.</span><span class="nf">cuboid</span><span class="p">(</span>
    <span class="nv">renderer</span><span class="p">:</span> <span class="n">renderer</span><span class="p">,</span>
    <span class="nv">width</span><span class="p">:</span> <span class="n">dimension</span><span class="p">,</span>
    <span class="nv">height</span><span class="p">:</span> <span class="n">dimension</span><span class="p">,</span>
    <span class="nv">length</span><span class="p">:</span> <span class="n">dimension</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Failed to create the cuboid mesh"</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="n">cubeMesh</span><span class="o">.</span><span class="n">material</span> <span class="o">=</span> <span class="n">material</span>

  <span class="k">let</span> <span class="nv">node</span> <span class="o">=</span> <span class="kt">Node</span><span class="p">(</span><span class="nv">mesh</span><span class="p">:</span> <span class="n">cubeMesh</span><span class="p">)</span>
  <span class="n">node</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="n">renderer</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="nf">addChild</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see we create a cube mesh, calling a helper method in the Primitives class, the load our texture from the bundle.
Once we have the texture we can create a BasicMaterial that understands texture coordinates and apply it to the mesh.
The final piece is to create a node and add it to the scene hierarchy.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_future">Future</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Toy3D only scratches the basics of what you can do with a 3D engine. Some immediate improvements we could make are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lighting Models: we already pass through the normal information through to the vertex shader, this can be used to add basic lighting information.</p>
</li>
<li>
<p>Multiple textures per mesh: Right now we are limited to one material for the entire mesh. It may be that you want to support multiple materials, you could add the concept of a submesh to the mesh class, where each submesh has a material and index in to the overall vertex buffer.</p>
</li>
<li>
<p>Add support for picking objects from the scene i.e. clicking on a model and highlighting it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And so on :)</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2019-12-17 12:15:00 -0800
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</body>
</html>